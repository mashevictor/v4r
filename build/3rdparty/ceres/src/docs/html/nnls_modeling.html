

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Modeling Non-linear Least Squares &mdash; Ceres Solver</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Ceres Solver" href="index.html"/>
        <link rel="next" title="Solving Non-linear Least Squares" href="nnls_solving.html"/>
        <link rel="prev" title="Interfacing with Automatic Differentiation" href="interfacing_with_autodiff.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Ceres Solver
          

          
          </a>

          
            
            
              <div class="version">
                1.13
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Why?</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="derivatives.html">On Derivatives</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modeling Non-linear Least Squares</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#costfunction"><code class="docutils literal"><span class="pre">CostFunction</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#sizedcostfunction"><code class="docutils literal"><span class="pre">SizedCostFunction</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#autodiffcostfunction"><code class="docutils literal"><span class="pre">AutoDiffCostFunction</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamicautodiffcostfunction"><code class="docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#numericdiffcostfunction"><code class="docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#numeric-differentiation-localparameterization">Numeric Differentiation &amp; LocalParameterization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dynamicnumericdiffcostfunction"><code class="docutils literal"><span class="pre">DynamicNumericDiffCostFunction</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#costfunctiontofunctor"><code class="docutils literal"><span class="pre">CostFunctionToFunctor</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamiccostfunctiontofunctor"><code class="docutils literal"><span class="pre">DynamicCostFunctionToFunctor</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#conditionedcostfunction"><code class="docutils literal"><span class="pre">ConditionedCostFunction</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#gradientchecker"><code class="docutils literal"><span class="pre">GradientChecker</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#normalprior"><code class="docutils literal"><span class="pre">NormalPrior</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#lossfunction"><code class="docutils literal"><span class="pre">LossFunction</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#instances">Instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="#theory">Theory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#localparameterization"><code class="docutils literal"><span class="pre">LocalParameterization</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">Instances</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#autodifflocalparameterization"><code class="docutils literal"><span class="pre">AutoDiffLocalParameterization</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#problem"><code class="docutils literal"><span class="pre">Problem</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#rotation-h"><code class="docutils literal"><span class="pre">rotation.h</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#cubic-interpolation">Cubic Interpolation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nnls_solving.html">Solving Non-linear Least Squares</a></li>
<li class="toctree-l1"><a class="reference internal" href="nnls_covariance.html">Covariance Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="gradient_solver.html">General Unconstrained Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="faqs.html">FAQS, Tips &amp; Tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="users.html">Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="version_history.html">Version History</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Ceres Solver</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Modeling Non-linear Least Squares</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="modeling-non-linear-least-squares">
<span id="chapter-nnls-modeling"></span><h1>Modeling Non-linear Least Squares<a class="headerlink" href="#modeling-non-linear-least-squares" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Ceres solver consists of two distinct parts. A modeling API which
provides a rich set of tools to construct an optimization problem one
term at a time and a solver API that controls the minimization
algorithm. This chapter is devoted to the task of modeling
optimization problems using Ceres. <a class="reference internal" href="nnls_solving.html#chapter-nnls-solving"><span class="std std-ref">Solving Non-linear Least Squares</span></a> discusses
the various ways in which an optimization problem can be solved using
Ceres.</p>
<p>Ceres solves robustified bounds constrained non-linear least squares
problems of the form:</p>
<div class="math" id="equation-ceresproblem">
<span class="eqno">(1)</span>\[\begin{split}\min_{\mathbf{x}} &amp;\quad \frac{1}{2}\sum_{i}
\rho_i\left(\left\|f_i\left(x_{i_1},
... ,x_{i_k}\right)\right\|^2\right)  \\
\text{s.t.} &amp;\quad l_j \le x_j \le u_j\end{split}\]</div>
<p>In Ceres parlance, the expression
<span class="math">\(\rho_i\left(\left\|f_i\left(x_{i_1},...,x_{i_k}\right)\right\|^2\right)\)</span>
is known as a <strong>residual block</strong>, where <span class="math">\(f_i(\cdot)\)</span> is a
<a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> that depends on the <strong>parameter blocks</strong>
<span class="math">\(\left\{x_{i_1},... , x_{i_k}\right\}\)</span>.</p>
<p>In most optimization problems small groups of scalars occur
together. For example the three components of a translation vector and
the four components of the quaternion that define the pose of a
camera. We refer to such a group of scalars as a <strong>parameter block</strong>. Of
course a parameter block can be just a single scalar too.</p>
<p><span class="math">\(\rho_i\)</span> is a <a class="reference internal" href="#_CPPv2N5ceres12LossFunctionE" title="ceres::LossFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></code></a>. A <a class="reference internal" href="#_CPPv2N5ceres12LossFunctionE" title="ceres::LossFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></code></a> is
a scalar valued function that is used to reduce the influence of
outliers on the solution of non-linear least squares problems.</p>
<p><span class="math">\(l_j\)</span> and <span class="math">\(u_j\)</span> are lower and upper bounds on the
parameter block <span class="math">\(x_j\)</span>.</p>
<p>As a special case, when <span class="math">\(\rho_i(x) = x\)</span>, i.e., the identity
function, and <span class="math">\(l_j = -\infty\)</span> and <span class="math">\(u_j = \infty\)</span> we get
the more familiar unconstrained <a class="reference external" href="http://en.wikipedia.org/wiki/Non-linear_least_squares">non-linear least squares problem</a>.</p>
<div class="math" id="equation-ceresproblemunconstrained">
<span class="eqno">(2)</span>\[\frac{1}{2}\sum_{i} \left\|f_i\left(x_{i_1}, ... ,x_{i_k}\right)\right\|^2.\]</div>
</div>
<div class="section" id="costfunction">
<h2><a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a><a class="headerlink" href="#costfunction" title="Permalink to this headline">¶</a></h2>
<p>For each term in the objective function, a <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> is
responsible for computing a vector of residuals and if asked a vector
of Jacobian matrices, i.e., given <span class="math">\(\left[x_{i_1}, ... ,
x_{i_k}\right]\)</span>, compute the vector
<span class="math">\(f_i\left(x_{i_1},...,x_{i_k}\right)\)</span> and the matrices</p>
<blockquote>
<div><div class="math">
\[J_{ij} = \frac{\partial}{\partial
x_{i_j}}f_i\left(x_{i_1},...,x_{i_k}\right),\quad \forall j
\in \{1, \ldots, k\}\]</div>
</div></blockquote>
<dl class="class">
<dt id="_CPPv2N5ceres12CostFunctionE">
<span id="ceres::CostFunction"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">CostFunction</code><a class="headerlink" href="#_CPPv2N5ceres12CostFunctionE" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CostFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;&amp;</span> <span class="n">parameter_block_sizes</span><span class="p">();</span>
  <span class="kt">int</span> <span class="nf">num_residuals</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

 <span class="k">protected</span><span class="o">:</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;*</span> <span class="n">mutable_parameter_block_sizes</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">set_num_residuals</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_residuals</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<p>The signature of the <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> (number and sizes of input
parameter blocks and number of outputs) is stored in
<code class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></code> and
<code class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::num_residuals_</span></code> respectively. User code
inheriting from this class is expected to set these two members with
the corresponding accessors. This information will be verified by the
<a class="reference internal" href="#_CPPv2N5ceres7ProblemE" title="ceres::Problem"><code class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></code></a> when added with <a class="reference internal" href="#_CPPv2N5ceres7Problem16AddResidualBlockEP12CostFunctionP12LossFunctionK6vectorIPdE" title="ceres::Problem::AddResidualBlock"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></code></a>.</p>
<dl class="function">
<dt id="_CPPv2N5ceres12CostFunction8EvaluateEPPCdPdPPd">
<span id="ceres::CostFunction::Evaluate__doubleCPCP.doubleP.doublePP"></span>bool <code class="descclassname">CostFunction::</code><code class="descname">Evaluate</code><span class="sig-paren">(</span>double <em class="property">const</em> *<em class="property">const</em> *<em>parameters</em>, double *<em>residuals</em>, double **<em>jacobians</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres12CostFunction8EvaluateEPPCdPdPPd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the residual vector and the Jacobian matrices.</p>
<p><code class="docutils literal"><span class="pre">parameters</span></code> is an array of pointers to arrays containing the
various parameter blocks. <code class="docutils literal"><span class="pre">parameters</span></code> has the same number of
elements as <code class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></code> and the
parameter blocks are in the same order as
<code class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></code>.</p>
<p><code class="docutils literal"><span class="pre">residuals</span></code> is an array of size <code class="docutils literal"><span class="pre">num_residuals_</span></code>.</p>
<p><code class="docutils literal"><span class="pre">jacobians</span></code> is an array of size
<code class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></code> containing pointers
to storage for Jacobian matrices corresponding to each parameter
block. The Jacobian matrices are in the same order as
<code class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></code>. <code class="docutils literal"><span class="pre">jacobians[i]</span></code> is
an array that contains <code class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::num_residuals_</span></code> x
<code class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></code> <code class="docutils literal"><span class="pre">[i]</span></code>
elements. Each Jacobian matrix is stored in row-major order, i.e.,
<code class="docutils literal"><span class="pre">jacobians[i][r</span> <span class="pre">*</span> <span class="pre">parameter_block_size_[i]</span> <span class="pre">+</span> <span class="pre">c]</span></code> =
<span class="math">\(\frac{\partial residual[r]}{\partial parameters[i][c]}\)</span></p>
<p>If <code class="docutils literal"><span class="pre">jacobians</span></code> is <code class="docutils literal"><span class="pre">NULL</span></code>, then no derivatives are returned;
this is the case when computing cost only. If <code class="docutils literal"><span class="pre">jacobians[i]</span></code> is
<code class="docutils literal"><span class="pre">NULL</span></code>, then the Jacobian matrix corresponding to the
<span class="math">\(i^{\textrm{th}}\)</span> parameter block must not be returned, this
is the case when a parameter block is marked constant.</p>
<p><strong>NOTE</strong> The return value indicates whether the computation of the
residuals and/or jacobians was successful or not.</p>
<p>This can be used to communicate numerical failures in Jacobian
computations for instance.</p>
</dd></dl>

</div>
<div class="section" id="sizedcostfunction">
<h2><a class="reference internal" href="#_CPPv2N5ceres17SizedCostFunctionE" title="ceres::SizedCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">SizedCostFunction</span></code></a><a class="headerlink" href="#sizedcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres17SizedCostFunctionE">
<span id="ceres::SizedCostFunction"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">SizedCostFunction</code><a class="headerlink" href="#_CPPv2N5ceres17SizedCostFunctionE" title="Permalink to this definition">¶</a></dt>
<dd><p>If the size of the parameter blocks and the size of the residual
vector is known at compile time (this is the common case),
<code class="xref cpp cpp-class docutils literal"><span class="pre">SizeCostFunction</span></code> can be used where these values can be
specified as template parameters and the user only needs to
implement <a class="reference internal" href="#_CPPv2N5ceres12CostFunction8EvaluateEPPCdPdPPd" title="ceres::CostFunction::Evaluate"><code class="xref cpp cpp-func docutils literal"><span class="pre">CostFunction::Evaluate()</span></code></a>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">kNumResiduals</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">N0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">N5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N9</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SizedCostFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="autodiffcostfunction">
<h2><a class="reference internal" href="#_CPPv2N5ceres20AutoDiffCostFunctionE" title="ceres::AutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></code></a><a class="headerlink" href="#autodiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres20AutoDiffCostFunctionE">
<span id="ceres::AutoDiffCostFunction"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">AutoDiffCostFunction</code><a class="headerlink" href="#_CPPv2N5ceres20AutoDiffCostFunctionE" title="Permalink to this definition">¶</a></dt>
<dd><p>Defining a <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> or a <a class="reference internal" href="#_CPPv2N5ceres17SizedCostFunctionE" title="ceres::SizedCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">SizedCostFunction</span></code></a>
can be a tedious and error prone especially when computing
derivatives.  To this end Ceres provides <a class="reference external" href="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CostFunctor</span><span class="p">,</span>
       <span class="kt">int</span> <span class="n">kNumResiduals</span><span class="p">,</span>  <span class="c1">// Number of residuals, or ceres::DYNAMIC.</span>
       <span class="kt">int</span> <span class="n">N0</span><span class="p">,</span>       <span class="c1">// Number of parameters in block 0.</span>
       <span class="kt">int</span> <span class="n">N1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 1.</span>
       <span class="kt">int</span> <span class="n">N2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 2.</span>
       <span class="kt">int</span> <span class="n">N3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 3.</span>
       <span class="kt">int</span> <span class="n">N4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 4.</span>
       <span class="kt">int</span> <span class="n">N5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 5.</span>
       <span class="kt">int</span> <span class="n">N6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 6.</span>
       <span class="kt">int</span> <span class="n">N7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 7.</span>
       <span class="kt">int</span> <span class="n">N8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 8.</span>
       <span class="kt">int</span> <span class="n">N9</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>   <span class="c1">// Number of parameters in block 9.</span>
<span class="k">class</span> <span class="nc">AutoDiffCostFunction</span> <span class="o">:</span> <span class="k">public</span>
<span class="n">SizedCostFunction</span><span class="o">&lt;</span><span class="n">kNumResiduals</span><span class="p">,</span> <span class="n">N0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">,</span> <span class="n">N4</span><span class="p">,</span> <span class="n">N5</span><span class="p">,</span> <span class="n">N6</span><span class="p">,</span> <span class="n">N7</span><span class="p">,</span> <span class="n">N8</span><span class="p">,</span> <span class="n">N9</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">AutoDiffCostFunction</span><span class="p">(</span><span class="n">CostFunctor</span><span class="o">*</span> <span class="n">functor</span><span class="p">);</span>
  <span class="c1">// Ignore the template parameter kNumResiduals and use</span>
  <span class="c1">// num_residuals instead.</span>
  <span class="n">AutoDiffCostFunction</span><span class="p">(</span><span class="n">CostFunctor</span><span class="o">*</span> <span class="n">functor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_residuals</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To get an auto differentiated cost function, you must define a
class with a templated <code class="docutils literal"><span class="pre">operator()</span></code> (a functor) that computes the
cost function in terms of the template parameter <code class="docutils literal"><span class="pre">T</span></code>. The
autodiff framework substitutes appropriate <code class="docutils literal"><span class="pre">Jet</span></code> objects for
<code class="docutils literal"><span class="pre">T</span></code> in order to compute the derivative when necessary, but this
is hidden, and you should write the function as if <code class="docutils literal"><span class="pre">T</span></code> were a
scalar type (e.g. a double-precision floating point number).</p>
<p>The function must write the computed value in the last argument
(the only non-<code class="docutils literal"><span class="pre">const</span></code> one) and return true to indicate success.</p>
<p>For example, consider a scalar error <span class="math">\(e = k - x^\top y\)</span>,
where both <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are two-dimensional vector
parameters and <span class="math">\(k\)</span> is a constant. The form of this error,
which is the difference between a constant and an expression, is a
common pattern in least squares problems. For example, the value
<span class="math">\(x^\top y\)</span> might be the model expectation for a series of
measurements, where there is an instance of the cost function for
each measurement <span class="math">\(k\)</span>.</p>
<p>The actual cost added to the total problem is <span class="math">\(e^2\)</span>, or
<span class="math">\((k - x^\top y)^2\)</span>; however, the squaring is implicitly done
by the optimization framework.</p>
<p>To write an auto-differentiable cost function for the above model,
first define the object</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyScalarCostFunctor</span> <span class="p">{</span>
  <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="kt">double</span> <span class="n">k</span><span class="p">)</span><span class="o">:</span> <span class="n">k_</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span> <span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">y</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">k_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that in the declaration of <code class="docutils literal"><span class="pre">operator()</span></code> the input parameters
<code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> come first, and are passed as const pointers to arrays
of <code class="docutils literal"><span class="pre">T</span></code>. If there were three input parameters, then the third input
parameter would come after <code class="docutils literal"><span class="pre">y</span></code>. The output is always the last
parameter, and is also a pointer to an array. In the example above,
<code class="docutils literal"><span class="pre">e</span></code> is a scalar, so only <code class="docutils literal"><span class="pre">e[0]</span></code> is set.</p>
<p>Then given this class definition, the auto differentiated cost
function for it can be constructed as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>              <span class="o">^</span>  <span class="o">^</span>  <span class="o">^</span>
                                                    <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
                        <span class="n">Dimension</span> <span class="n">of</span> <span class="n">residual</span> <span class="o">------+</span>  <span class="o">|</span>  <span class="o">|</span>
                        <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">----------------+</span>  <span class="o">|</span>
                        <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">-------------------+</span>
</pre></div>
</div>
<p>In this example, there is usually an instance for each measurement
of <code class="docutils literal"><span class="pre">k</span></code>.</p>
<p>In the instantiation above, the template parameters following
<code class="docutils literal"><span class="pre">MyScalarCostFunction</span></code>, <code class="docutils literal"><span class="pre">&lt;1,</span> <span class="pre">2,</span> <span class="pre">2&gt;</span></code> describe the functor as
computing a 1-dimensional output from two arguments, both
2-dimensional.</p>
<p><a class="reference internal" href="#_CPPv2N5ceres20AutoDiffCostFunctionE" title="ceres::AutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></code></a> also supports cost functions with a
runtime-determined number of residuals. For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="n">DYNAMIC</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">CostFunctorWithDynamicNumResiduals</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>   <span class="o">^</span>     <span class="o">^</span>  <span class="o">^</span>
        <span class="n">runtime_number_of_residuals</span><span class="p">);</span> <span class="o">&lt;----+</span>           <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
                                           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
                                           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Actual</span> <span class="n">number</span> <span class="n">of</span> <span class="n">residuals</span> <span class="o">------+</span>           <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Indicate</span> <span class="n">dynamic</span> <span class="n">number</span> <span class="n">of</span> <span class="n">residuals</span> <span class="o">--------+</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">------------------------------------+</span>  <span class="o">|</span>
          <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">---------------------------------------+</span>
</pre></div>
</div>
<p>The framework can currently accommodate cost functions of up to 10
independent variables, and there is no limit on the dimensionality
of each of them.</p>
<p><strong>WARNING 1</strong> A common beginner&#8217;s error when first using
<a class="reference internal" href="#_CPPv2N5ceres20AutoDiffCostFunctionE" title="ceres::AutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></code></a> is to get the sizing wrong. In particular,
there is a tendency to set the template parameters to (dimension of
residual, number of parameters) instead of passing a dimension
parameter for <em>every parameter block</em>. In the example above, that
would be <code class="docutils literal"><span class="pre">&lt;MyScalarCostFunction,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></code>, which is missing the 2
as the last template argument.</p>
</dd></dl>

</div>
<div class="section" id="dynamicautodiffcostfunction">
<h2><a class="reference internal" href="#_CPPv2N5ceres27DynamicAutoDiffCostFunctionE" title="ceres::DynamicAutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></code></a><a class="headerlink" href="#dynamicautodiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres27DynamicAutoDiffCostFunctionE">
<span id="ceres::DynamicAutoDiffCostFunction"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">DynamicAutoDiffCostFunction</code><a class="headerlink" href="#_CPPv2N5ceres27DynamicAutoDiffCostFunctionE" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#_CPPv2N5ceres20AutoDiffCostFunctionE" title="ceres::AutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></code></a> requires that the number of parameter
blocks and their sizes be known at compile time. It also has an
upper limit of 10 parameter blocks. In a number of applications,
this is not enough e.g., Bezier curve fitting, Neural Network
training etc.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CostFunctor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Stride</span> <span class="o">=</span> <span class="mi">4</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">DynamicAutoDiffCostFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>In such cases <a class="reference internal" href="#_CPPv2N5ceres27DynamicAutoDiffCostFunctionE" title="ceres::DynamicAutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></code></a> can be
used. Like <a class="reference internal" href="#_CPPv2N5ceres20AutoDiffCostFunctionE" title="ceres::AutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></code></a> the user must define a
templated functor, but the signature of the functor differs
slightly. The expected interface for the cost functors is:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">MyCostFunctor</span> <span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Since the sizing of the parameters is done at runtime, you must
also specify the sizes after creating the dynamic autodiff cost
function. For example:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">DynamicAutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyCostFunctor</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;*</span> <span class="n">cost_function</span> <span class="o">=</span>
  <span class="k">new</span> <span class="n">DynamicAutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyCostFunctor</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">MyCostFunctor</span><span class="p">());</span>
<span class="n">cost_function</span><span class="o">-&gt;</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">cost_function</span><span class="o">-&gt;</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">cost_function</span><span class="o">-&gt;</span><span class="n">SetNumResiduals</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Under the hood, the implementation evaluates the cost function
multiple times, computing a small set of the derivatives (four by
default, controlled by the <code class="docutils literal"><span class="pre">Stride</span></code> template parameter) with each
pass. There is a performance tradeoff with the size of the passes;
Smaller sizes are more cache efficient but result in larger number
of passes, and larger stride lengths can destroy cache-locality
while reducing the number of passes over the cost function. The
optimal value depends on the number and sizes of the various
parameter blocks.</p>
<p>As a rule of thumb, try using <a class="reference internal" href="#_CPPv2N5ceres20AutoDiffCostFunctionE" title="ceres::AutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></code></a> before
you use <a class="reference internal" href="#_CPPv2N5ceres27DynamicAutoDiffCostFunctionE" title="ceres::DynamicAutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="numericdiffcostfunction">
<h2><a class="reference internal" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="ceres::NumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a><a class="headerlink" href="#numericdiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres23NumericDiffCostFunctionE">
<span id="ceres::NumericDiffCostFunction"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">NumericDiffCostFunction</code><a class="headerlink" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="Permalink to this definition">¶</a></dt>
<dd><p>In some cases, its not possible to define a templated cost functor,
for example when the evaluation of the residual involves a call to a
library function that you do not have control over.  In such a
situation, <a class="reference external" href="http://en.wikipedia.org/wiki/Numerical_differentiation">numerical differentiation</a> can be
used.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO(sameeragarwal): Add documentation for the constructor and for
NumericDiffOptions. Update DynamicNumericDiffOptions in a similar
manner.</p>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CostFunctor</span><span class="p">,</span>
          <span class="n">NumericDiffMethodType</span> <span class="n">method</span> <span class="o">=</span> <span class="n">CENTRAL</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">kNumResiduals</span><span class="p">,</span>  <span class="c1">// Number of residuals, or ceres::DYNAMIC.</span>
          <span class="kt">int</span> <span class="n">N0</span><span class="p">,</span>       <span class="c1">// Number of parameters in block 0.</span>
          <span class="kt">int</span> <span class="n">N1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 1.</span>
          <span class="kt">int</span> <span class="n">N2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 2.</span>
          <span class="kt">int</span> <span class="n">N3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 3.</span>
          <span class="kt">int</span> <span class="n">N4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 4.</span>
          <span class="kt">int</span> <span class="n">N5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 5.</span>
          <span class="kt">int</span> <span class="n">N6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 6.</span>
          <span class="kt">int</span> <span class="n">N7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 7.</span>
          <span class="kt">int</span> <span class="n">N8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 8.</span>
          <span class="kt">int</span> <span class="n">N9</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>   <span class="c1">// Number of parameters in block 9.</span>
<span class="k">class</span> <span class="nc">NumericDiffCostFunction</span> <span class="o">:</span> <span class="k">public</span>
<span class="n">SizedCostFunction</span><span class="o">&lt;</span><span class="n">kNumResiduals</span><span class="p">,</span> <span class="n">N0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">,</span> <span class="n">N4</span><span class="p">,</span> <span class="n">N5</span><span class="p">,</span> <span class="n">N6</span><span class="p">,</span> <span class="n">N7</span><span class="p">,</span> <span class="n">N8</span><span class="p">,</span> <span class="n">N9</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To get a numerically differentiated <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a>, you must
define a class with a <code class="docutils literal"><span class="pre">operator()</span></code> (a functor) that computes the
residuals. The functor must write the computed value in the last
argument (the only non-<code class="docutils literal"><span class="pre">const</span></code> one) and return <code class="docutils literal"><span class="pre">true</span></code> to
indicate success.  Please see <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> for details on
how the return value may be used to impose simple constraints on the
parameter block. e.g., an object of the form</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ScalarFunctor</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x1</span><span class="p">,</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x2</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For example, consider a scalar error <span class="math">\(e = k - x'y\)</span>, where both
<span class="math">\(x\)</span> and <span class="math">\(y\)</span> are two-dimensional column vector
parameters, the prime sign indicates transposition, and <span class="math">\(k\)</span> is
a constant. The form of this error, which is the difference between
a constant and an expression, is a common pattern in least squares
problems. For example, the value <span class="math">\(x'y\)</span> might be the model
expectation for a series of measurements, where there is an instance
of the cost function for each measurement <span class="math">\(k\)</span>.</p>
<p>To write an numerically-differentiable class:<cite>CostFunction</cite> for the
above model, first define the object</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyScalarCostFunctor</span> <span class="p">{</span>
  <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="kt">double</span> <span class="n">k</span><span class="p">)</span><span class="o">:</span> <span class="n">k_</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">y</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">k_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that in the declaration of <code class="docutils literal"><span class="pre">operator()</span></code> the input parameters
<code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> come first, and are passed as const pointers to
arrays of <code class="docutils literal"><span class="pre">double</span></code> s. If there were three input parameters, then
the third input parameter would come after <code class="docutils literal"><span class="pre">y</span></code>. The output is
always the last parameter, and is also a pointer to an array. In the
example above, the residual is a scalar, so only <code class="docutils literal"><span class="pre">residuals[0]</span></code> is
set.</p>
<p>Then given this class definition, the numerically differentiated
<a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> with central differences used for computing
the derivative can be constructed as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>                    <span class="o">^</span>     <span class="o">^</span>  <span class="o">^</span>  <span class="o">^</span>
                                                          <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
                              <span class="n">Finite</span> <span class="n">Differencing</span> <span class="n">Scheme</span> <span class="o">-+</span>     <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
                              <span class="n">Dimension</span> <span class="n">of</span> <span class="n">residual</span> <span class="o">------------+</span>  <span class="o">|</span>  <span class="o">|</span>
                              <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">----------------------+</span>  <span class="o">|</span>
                              <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">-------------------------+</span>
</pre></div>
</div>
<p>In this example, there is usually an instance for each measurement
of <cite>k</cite>.</p>
<p>In the instantiation above, the template parameters following
<code class="docutils literal"><span class="pre">MyScalarCostFunctor</span></code>, <code class="docutils literal"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">2</span></code>, describe the functor as
computing a 1-dimensional output from two arguments, both
2-dimensional.</p>
<p>NumericDiffCostFunction also supports cost functions with a
runtime-determined number of residuals. For example:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="n">DYNAMIC</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">CostFunctorWithDynamicNumResiduals</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>               <span class="o">^</span>     <span class="o">^</span>  <span class="o">^</span>
        <span class="n">TAKE_OWNERSHIP</span><span class="p">,</span>                                            <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
        <span class="n">runtime_number_of_residuals</span><span class="p">);</span> <span class="o">&lt;----+</span>                       <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
                                           <span class="o">|</span>                       <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
                                           <span class="o">|</span>                       <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Actual</span> <span class="n">number</span> <span class="n">of</span> <span class="n">residuals</span> <span class="o">------+</span>                       <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Indicate</span> <span class="n">dynamic</span> <span class="n">number</span> <span class="n">of</span> <span class="n">residuals</span> <span class="o">--------------------+</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">------------------------------------------------+</span>  <span class="o">|</span>
          <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">---------------------------------------------------+</span>
</pre></div>
</div>
</div></blockquote>
<p>The framework can currently accommodate cost functions of up to 10
independent variables, and there is no limit on the dimensionality
of each of them.</p>
<p>There are three available numeric differentiation schemes in ceres-solver:</p>
<p>The <code class="docutils literal"><span class="pre">FORWARD</span></code> difference method, which approximates <span class="math">\(f'(x)\)</span>
by computing <span class="math">\(\frac{f(x+h)-f(x)}{h}\)</span>, computes the cost
function one additional time at <span class="math">\(x+h\)</span>. It is the fastest but
least accurate method.</p>
<p>The <code class="docutils literal"><span class="pre">CENTRAL</span></code> difference method is more accurate at the cost of
twice as many function evaluations than forward difference,
estimating <span class="math">\(f'(x)\)</span> by computing
<span class="math">\(\frac{f(x+h)-f(x-h)}{2h}\)</span>.</p>
<p>The <code class="docutils literal"><span class="pre">RIDDERS</span></code> difference method[Ridders]_ is an adaptive scheme
that estimates derivatives by performing multiple central
differences at varying scales. Specifically, the algorithm starts at
a certain <span class="math">\(h\)</span> and as the derivative is estimated, this step
size decreases.  To conserve function evaluations and estimate the
derivative error, the method performs Richardson extrapolations
between the tested step sizes.  The algorithm exhibits considerably
higher accuracy, but does so by additional evaluations of the cost
function.</p>
<p>Consider using <code class="docutils literal"><span class="pre">CENTRAL</span></code> differences to begin with. Based on the
results, either try forward difference to improve performance or
Ridders&#8217; method to improve accuracy.</p>
<p><strong>WARNING</strong> A common beginner&#8217;s error when first using
<a class="reference internal" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="ceres::NumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a> is to get the sizing wrong. In
particular, there is a tendency to set the template parameters to
(dimension of residual, number of parameters) instead of passing a
dimension parameter for <em>every parameter</em>. In the example above,
that would be <code class="docutils literal"><span class="pre">&lt;MyScalarCostFunctor,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></code>, which is missing the
last <code class="docutils literal"><span class="pre">2</span></code> argument. Please be careful when setting the size
parameters.</p>
</dd></dl>

<div class="section" id="numeric-differentiation-localparameterization">
<h3>Numeric Differentiation &amp; LocalParameterization<a class="headerlink" href="#numeric-differentiation-localparameterization" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If your cost function depends on a parameter block that must lie on
a manifold and the functor cannot be evaluated for values of that
parameter block not on the manifold then you may have problems
numerically differentiating such functors.</p>
<p>This is because numeric differentiation in Ceres is performed by
perturbing the individual coordinates of the parameter blocks that
a cost functor depends on. In doing so, we assume that the
parameter blocks live in an Euclidean space and ignore the
structure of manifold that they live As a result some of the
perturbations may not lie on the manifold corresponding to the
parameter block.</p>
<p>For example consider a four dimensional parameter block that is
interpreted as a unit Quaternion. Perturbing the coordinates of
this parameter block will violate the unit norm property of the
parameter block.</p>
<p>Fixing this problem requires that <a class="reference internal" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="ceres::NumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a>
be aware of the <a class="reference internal" href="#_CPPv2N5ceres21LocalParameterizationE" title="ceres::LocalParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></code></a> associated with each
parameter block and only generate perturbations in the local
tangent space of each parameter block.</p>
<p>For now this is not considered to be a serious enough problem to
warrant changing the <a class="reference internal" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="ceres::NumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a> API. Further,
in most cases it is relatively straightforward to project a point
off the manifold back onto the manifold before using it in the
functor. For example in case of the Quaternion, normalizing the
4-vector before using it does the trick.</p>
<p><strong>Alternate Interface</strong></p>
<p>For a variety of reasons, including compatibility with legacy code,
<a class="reference internal" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="ceres::NumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a> can also take
<a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> objects as input. The following describes
how.</p>
<p>To get a numerically differentiated cost function, define a
subclass of <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> such that the
<a class="reference internal" href="#_CPPv2N5ceres12CostFunction8EvaluateEPPCdPdPPd" title="ceres::CostFunction::Evaluate"><code class="xref cpp cpp-func docutils literal"><span class="pre">CostFunction::Evaluate()</span></code></a> function ignores the <code class="docutils literal"><span class="pre">jacobians</span></code>
parameter. The numeric differentiation wrapper will fill in the
jacobian parameter if necessary by repeatedly calling the
<a class="reference internal" href="#_CPPv2N5ceres12CostFunction8EvaluateEPPCdPdPPd" title="ceres::CostFunction::Evaluate"><code class="xref cpp cpp-func docutils literal"><span class="pre">CostFunction::Evaluate()</span></code></a> with small changes to the
appropriate parameters, and computing the slope. For performance,
the numeric differentiation wrapper class is templated on the
concrete cost function, even though it could be implemented only in
terms of the <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> interface.</p>
<p>The numerically differentiated version of a cost function for a
cost function can be constructed as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyCostFunction</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">MyCostFunction</span><span class="p">(...),</span> <span class="n">TAKE_OWNERSHIP</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">MyCostFunction</span></code> has 1 residual and 2 parameter blocks with
sizes 4 and 8 respectively. Look at the tests for a more detailed
example.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="dynamicnumericdiffcostfunction">
<h2><a class="reference internal" href="#_CPPv2N5ceres30DynamicNumericDiffCostFunctionE" title="ceres::DynamicNumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicNumericDiffCostFunction</span></code></a><a class="headerlink" href="#dynamicnumericdiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres30DynamicNumericDiffCostFunctionE">
<span id="ceres::DynamicNumericDiffCostFunction"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">DynamicNumericDiffCostFunction</code><a class="headerlink" href="#_CPPv2N5ceres30DynamicNumericDiffCostFunctionE" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#_CPPv2N5ceres20AutoDiffCostFunctionE" title="ceres::AutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></code></a> <a class="reference internal" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="ceres::NumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a>
requires that the number of parameter blocks and their sizes be
known at compile time. It also has an upper limit of 10 parameter
blocks. In a number of applications, this is not enough.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CostFunctor</span><span class="p">,</span> <span class="n">NumericDiffMethodType</span> <span class="n">method</span> <span class="o">=</span> <span class="n">CENTRAL</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">DynamicNumericDiffCostFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>In such cases when numeric differentiation is desired,
<a class="reference internal" href="#_CPPv2N5ceres30DynamicNumericDiffCostFunctionE" title="ceres::DynamicNumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicNumericDiffCostFunction</span></code></a> can be used.</p>
<p>Like <a class="reference internal" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="ceres::NumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a> the user must define a
functor, but the signature of the functor differs slightly. The
expected interface for the cost functors is:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">MyCostFunctor</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Since the sizing of the parameters is done at runtime, you must
also specify the sizes after creating the dynamic numeric diff cost
function. For example:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">DynamicNumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyCostFunctor</span><span class="o">&gt;*</span> <span class="n">cost_function</span> <span class="o">=</span>
  <span class="k">new</span> <span class="n">DynamicNumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyCostFunctor</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">MyCostFunctor</span><span class="p">);</span>
<span class="n">cost_function</span><span class="o">-&gt;</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">cost_function</span><span class="o">-&gt;</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">cost_function</span><span class="o">-&gt;</span><span class="n">SetNumResiduals</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>As a rule of thumb, try using <a class="reference internal" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="ceres::NumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a> before
you use <a class="reference internal" href="#_CPPv2N5ceres30DynamicNumericDiffCostFunctionE" title="ceres::DynamicNumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicNumericDiffCostFunction</span></code></a>.</p>
<p><strong>WARNING</strong> The same caution about mixing local parameterizations
with numeric differentiation applies as is the case with
<a class="reference internal" href="#_CPPv2N5ceres23NumericDiffCostFunctionE" title="ceres::NumericDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="costfunctiontofunctor">
<h2><a class="reference internal" href="#_CPPv2N5ceres21CostFunctionToFunctorE" title="ceres::CostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></code></a><a class="headerlink" href="#costfunctiontofunctor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres21CostFunctionToFunctorE">
<span id="ceres::CostFunctionToFunctor"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">CostFunctionToFunctor</code><a class="headerlink" href="#_CPPv2N5ceres21CostFunctionToFunctorE" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p><a class="reference internal" href="#_CPPv2N5ceres21CostFunctionToFunctorE" title="ceres::CostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></code></a> is an adapter class that allows
users to use <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> objects in templated functors
which are to be used for automatic differentiation. This allows
the user to seamlessly mix analytic, numeric and automatic
differentiation.</p>
<p>For example, let us assume that</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IntrinsicProjection</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SizedCostFunction</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                          <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                          <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>is a <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> that implements the projection of a
point in its local coordinate system onto its image plane and
subtracts it from the observed point projection. It can compute its
residual and either via analytic or numerical differentiation can
compute its jacobians.</p>
<p>Now we would like to compose the action of this
<a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> with the action of camera extrinsics, i.e.,
rotation and translation. Say we have a templated function</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                             <span class="n">T</span><span class="o">*</span> <span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>Then we can now do the following,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">CameraProjection</span> <span class="p">{</span>
  <span class="n">CameraProjection</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">intrinsic_projection_</span><span class="p">(</span><span class="k">new</span> <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="n">observation</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">intrinsics</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                  <span class="n">T</span><span class="o">*</span> <span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">transformed_point</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">);</span>

    <span class="c1">// Note that we call intrinsic_projection_, just like it was</span>
    <span class="c1">// any other templated functor.</span>
    <span class="k">return</span> <span class="nf">intrinsic_projection_</span><span class="p">(</span><span class="n">intrinsics</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">CostFunctionToFunctor</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">intrinsic_projection_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#_CPPv2N5ceres21CostFunctionToFunctorE" title="ceres::CostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></code></a> takes ownership of the
<a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> that was passed in to the constructor.</p>
<p>In the above example, we assumed that <code class="docutils literal"><span class="pre">IntrinsicProjection</span></code> is a
<code class="docutils literal"><span class="pre">CostFunction</span></code> capable of evaluating its value and its
derivatives. Suppose, if that were not the case and
<code class="docutils literal"><span class="pre">IntrinsicProjection</span></code> was defined as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">IntrinsicProjection</span>
  <span class="nf">IntrinsicProjection</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">observation_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">observation</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">observation_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">observation</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">calibration</span><span class="p">,</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">projection</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">ThirdPartyProjectionFunction</span><span class="p">(</span><span class="n">calibration</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">projection</span><span class="p">);</span>
    <span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">observation_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">residuals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">observation_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">projection</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
 <span class="kt">double</span> <span class="n">observation_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>Here <code class="docutils literal"><span class="pre">ThirdPartyProjectionFunction</span></code> is some third party library
function that we have no control over. So this function can compute
its value and we would like to use numeric differentiation to
compute its derivatives. In this case we can use a combination of
<code class="docutils literal"><span class="pre">NumericDiffCostFunction</span></code> and <code class="docutils literal"><span class="pre">CostFunctionToFunctor</span></code> to get the
job done.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">CameraProjection</span> <span class="p">{</span>
  <span class="n">CameraProjection</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">)</span>
    <span class="n">intrinsic_projection_</span><span class="p">(</span>
      <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">IntrinsicProjection</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="n">observation</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">intrinsics</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                  <span class="n">T</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">transformed_point</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">intrinsic_projection_</span><span class="p">(</span><span class="n">intrinsics</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">CostFunctionToFunctor</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">intrinsic_projection_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="dynamiccostfunctiontofunctor">
<h2><a class="reference internal" href="#_CPPv2N5ceres28DynamicCostFunctionToFunctorE" title="ceres::DynamicCostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicCostFunctionToFunctor</span></code></a><a class="headerlink" href="#dynamiccostfunctiontofunctor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres28DynamicCostFunctionToFunctorE">
<span id="ceres::DynamicCostFunctionToFunctor"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">DynamicCostFunctionToFunctor</code><a class="headerlink" href="#_CPPv2N5ceres28DynamicCostFunctionToFunctorE" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#_CPPv2N5ceres28DynamicCostFunctionToFunctorE" title="ceres::DynamicCostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicCostFunctionToFunctor</span></code></a> provides the same functionality as
<a class="reference internal" href="#_CPPv2N5ceres21CostFunctionToFunctorE" title="ceres::CostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></code></a> for cases where the number and size of the
parameter vectors and residuals are not known at compile-time. The API
provided by <a class="reference internal" href="#_CPPv2N5ceres28DynamicCostFunctionToFunctorE" title="ceres::DynamicCostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicCostFunctionToFunctor</span></code></a> matches what would be
expected by <a class="reference internal" href="#_CPPv2N5ceres27DynamicAutoDiffCostFunctionE" title="ceres::DynamicAutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></code></a>, i.e. it provides a
templated functor of this form:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Similar to the example given for <a class="reference internal" href="#_CPPv2N5ceres21CostFunctionToFunctorE" title="ceres::CostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></code></a>, let us
assume that</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IntrinsicProjection</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                          <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                          <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>is a <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> that projects a point in its local coordinate
system onto its image plane and subtracts it from the observed point
projection.</p>
<p>Using this <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> in a templated functor would then look like
this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">CameraProjection</span> <span class="p">{</span>
  <span class="n">CameraProjection</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">intrinsic_projection_</span><span class="p">(</span><span class="k">new</span> <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="n">observation</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                  <span class="n">T</span><span class="o">*</span> <span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">intrinsics</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

    <span class="n">T</span> <span class="n">transformed_point</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">projection_parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">projection_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">intrinsics</span><span class="p">;</span>
    <span class="n">projection_parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_point</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">intrinsic_projection_</span><span class="p">(</span><span class="n">projection_parameters</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">DynamicCostFunctionToFunctor</span> <span class="n">intrinsic_projection_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Like <a class="reference internal" href="#_CPPv2N5ceres21CostFunctionToFunctorE" title="ceres::CostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></code></a>, <a class="reference internal" href="#_CPPv2N5ceres28DynamicCostFunctionToFunctorE" title="ceres::DynamicCostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">DynamicCostFunctionToFunctor</span></code></a>
takes ownership of the <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> that was passed in to the
constructor.</p>
</dd></dl>

</div>
<div class="section" id="conditionedcostfunction">
<h2><a class="reference internal" href="#_CPPv2N5ceres23ConditionedCostFunctionE" title="ceres::ConditionedCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">ConditionedCostFunction</span></code></a><a class="headerlink" href="#conditionedcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres23ConditionedCostFunctionE">
<span id="ceres::ConditionedCostFunction"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">ConditionedCostFunction</code><a class="headerlink" href="#_CPPv2N5ceres23ConditionedCostFunctionE" title="Permalink to this definition">¶</a></dt>
<dd><p>This class allows you to apply different conditioning to the residual
values of a wrapped cost function. An example where this is useful is
where you have an existing cost function that produces N values, but you
want the total cost to be something other than just the sum of these
squared values - maybe you want to apply a different scaling to some
values, to change their contribution to the cost.</p>
<p>Usage:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">//  my_cost_function produces N residuals</span>
<span class="n">CostFunction</span><span class="o">*</span> <span class="n">my_cost_function</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">CHECK_EQ</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">my_cost_function</span><span class="o">-&gt;</span><span class="n">num_residuals</span><span class="p">());</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">CostFunction</span><span class="o">*&gt;</span> <span class="n">conditioners</span><span class="p">;</span>

<span class="c1">//  Make N 1x1 cost functions (1 parameter, 1 residual)</span>
<span class="n">CostFunction</span><span class="o">*</span> <span class="n">f_1</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">conditioners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">f_1</span><span class="p">);</span>

<span class="n">CostFunction</span><span class="o">*</span> <span class="n">f_N</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">conditioners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">f_N</span><span class="p">);</span>
<span class="n">ConditionedCostFunction</span><span class="o">*</span> <span class="n">ccf</span> <span class="o">=</span>
  <span class="k">new</span> <span class="n">ConditionedCostFunction</span><span class="p">(</span><span class="n">my_cost_function</span><span class="p">,</span> <span class="n">conditioners</span><span class="p">);</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">ccf</span></code> &#8216;s <code class="docutils literal"><span class="pre">residual[i]</span></code> (i=0..N-1) will be passed though the
<span class="math">\(i^{\text{th}}\)</span> conditioner.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ccf_residual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_i</span><span class="p">(</span><span class="n">my_cost_function_residual</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>and the Jacobian will be affected appropriately.</p>
</dd></dl>

</div>
<div class="section" id="gradientchecker">
<h2><a class="reference internal" href="#_CPPv2N5ceres15GradientCheckerE" title="ceres::GradientChecker"><code class="xref cpp cpp-class docutils literal"><span class="pre">GradientChecker</span></code></a><a class="headerlink" href="#gradientchecker" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres15GradientCheckerE">
<span id="ceres::GradientChecker"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">GradientChecker</code><a class="headerlink" href="#_CPPv2N5ceres15GradientCheckerE" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>This class compares the Jacobians returned by a cost function against
derivatives estimated using finite differencing. It is meant as a tool for
unit testing, giving you more fine-grained control than the check_gradients
option in the solver options.</p>
<p>The condition enforced is that</p>
<div class="math">
\[\forall{i,j}: \frac{J_{ij} - J'_{ij}}{max_{ij}(J_{ij} - J'_{ij})} &lt; r\]</div>
<p>where <span class="math">\(J_{ij}\)</span> is the jacobian as computed by the supplied cost
function (by the user) multiplied by the local parameterization Jacobian,
<span class="math">\(J'_{ij}\)</span> is the jacobian as computed by finite differences,
multiplied by the local parameterization Jacobian as well, and <span class="math">\(r\)</span>
is the relative precision.</p>
</div></blockquote>
<p>Usage:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">//  my_cost_function takes two parameter blocks. The first has a local</span>
<span class="c1">//  parameterization associated with it.</span>
<span class="n">CostFunction</span><span class="o">*</span> <span class="n">my_cost_function</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">LocalParameterization</span><span class="o">*</span> <span class="n">my_parameterization</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">NumericDiffOptions</span> <span class="n">numeric_diff_options</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LocalParameterization</span><span class="o">*&gt;</span> <span class="n">local_parameterizations</span><span class="p">;</span>
<span class="n">local_parameterizations</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">my_parameterization</span><span class="p">);</span>
<span class="n">local_parameterizations</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">parameter1</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">parameter2</span><span class="p">;</span>
<span class="c1">// Fill parameter 1 &amp; 2 with test data...</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">*&gt;</span> <span class="n">parameter_blocks</span><span class="p">;</span>
<span class="n">parameter_blocks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">parameter1</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="n">parameter_blocks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">parameter2</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="n">GradientChecker</span> <span class="nf">gradient_checker</span><span class="p">(</span><span class="n">my_cost_function</span><span class="p">,</span>
    <span class="n">local_parameterizations</span><span class="p">,</span> <span class="n">numeric_diff_options</span><span class="p">);</span>
<span class="n">GradientCheckResults</span> <span class="n">results</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gradient_checker</span><span class="p">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">parameter_blocks</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">results</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;An error has occurred:</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">results</span><span class="p">.</span><span class="n">error_log</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="normalprior">
<h2><a class="reference internal" href="#_CPPv2N5ceres11NormalPriorE" title="ceres::NormalPrior"><code class="xref cpp cpp-class docutils literal"><span class="pre">NormalPrior</span></code></a><a class="headerlink" href="#normalprior" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres11NormalPriorE">
<span id="ceres::NormalPrior"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">NormalPrior</code><a class="headerlink" href="#_CPPv2N5ceres11NormalPriorE" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NormalPrior</span><span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Check that the number of rows in the vector b are the same as the</span>
  <span class="c1">// number of columns in the matrix A, crash otherwise.</span>
  <span class="n">NormalPrior</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
 <span class="p">};</span>
</pre></div>
</div>
<p>Implements a cost function of the form</p>
<div class="math">
\[cost(x) = ||A(x - b)||^2\]</div>
<p>where, the matrix <span class="math">\(A\)</span> and the vector <span class="math">\(b\)</span> are fixed and <span class="math">\(x\)</span>
is the variable. In case the user is interested in implementing a cost
function of the form</p>
</div></blockquote>
<div class="math">
\[cost(x) = (x - \mu)^T S^{-1} (x - \mu)\]</div>
<p>where, <span class="math">\(\mu\)</span> is a vector and <span class="math">\(S\)</span> is a covariance matrix,
then, <span class="math">\(A = S^{-1/2}\)</span>, i.e the matrix <span class="math">\(A\)</span> is the square
root of the inverse of the covariance, also known as the stiffness
matrix. There are however no restrictions on the shape of
<span class="math">\(A\)</span>. It is free to be rectangular, which would be the case if
the covariance matrix <span class="math">\(S\)</span> is rank deficient.</p>
</dd></dl>

</div>
<div class="section" id="lossfunction">
<span id="section-loss-function"></span><h2><a class="reference internal" href="#_CPPv2N5ceres12LossFunctionE" title="ceres::LossFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></code></a><a class="headerlink" href="#lossfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres12LossFunctionE">
<span id="ceres::LossFunction"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">LossFunction</code><a class="headerlink" href="#_CPPv2N5ceres12LossFunctionE" title="Permalink to this definition">¶</a></dt>
<dd><p>For least squares problems where the minimization may encounter
input terms that contain outliers, that is, completely bogus
measurements, it is important to use a loss function that reduces
their influence.</p>
<p>Consider a structure from motion problem. The unknowns are 3D
points and camera parameters, and the measurements are image
coordinates describing the expected reprojected position for a
point in a camera. For example, we want to model the geometry of a
street scene with fire hydrants and cars, observed by a moving
camera with unknown parameters, and the only 3D points we care
about are the pointy tippy-tops of the fire hydrants. Our magic
image processing algorithm, which is responsible for producing the
measurements that are input to Ceres, has found and matched all
such tippy-tops in all image frames, except that in one of the
frame it mistook a car&#8217;s headlight for a hydrant. If we didn&#8217;t do
anything special the residual for the erroneous measurement will
result in the entire solution getting pulled away from the optimum
to reduce the large error that would otherwise be attributed to the
wrong measurement.</p>
<p>Using a robust loss function, the cost for large residuals is
reduced. In the example above, this leads to outlier terms getting
down-weighted so they do not overly influence the final solution.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LossFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The key method is <code class="xref cpp cpp-func docutils literal"><span class="pre">LossFunction::Evaluate()</span></code>, which given a
non-negative scalar <code class="docutils literal"><span class="pre">s</span></code>, computes</p>
<div class="math">
\[out = \begin{bmatrix}\rho(s), &amp; \rho'(s), &amp; \rho''(s)\end{bmatrix}\]</div>
<p>Here the convention is that the contribution of a term to the cost
function is given by <span class="math">\(\frac{1}{2}\rho(s)\)</span>, where <span class="math">\(s
=\|f_i\|^2\)</span>. Calling the method with a negative value of <span class="math">\(s\)</span>
is an error and the implementations are not required to handle that
case.</p>
<p>Most sane choices of <span class="math">\(\rho\)</span> satisfy:</p>
<div class="math">
\[\begin{split}\rho(0) &amp;= 0\\
\rho'(0) &amp;= 1\\
\rho'(s) &amp;&lt; 1 \text{ in the outlier region}\\
\rho''(s) &amp;&lt; 0 \text{ in the outlier region}\end{split}\]</div>
<p>so that they mimic the squared cost for small residuals.</p>
<p><strong>Scaling</strong></p>
<p>Given one robustifier <span class="math">\(\rho(s)\)</span> one can change the length
scale at which robustification takes place, by adding a scale
factor <span class="math">\(a &gt; 0\)</span> which gives us <span class="math">\(\rho(s,a) = a^2 \rho(s /
a^2)\)</span> and the first and second derivatives as <span class="math">\(\rho'(s /
a^2)\)</span> and <span class="math">\((1 / a^2) \rho''(s / a^2)\)</span> respectively.</p>
<p>The reason for the appearance of squaring is that <span class="math">\(a\)</span> is in
the units of the residual vector norm whereas <span class="math">\(s\)</span> is a squared
norm. For applications it is more convenient to specify <span class="math">\(a\)</span> than
its square.</p>
</dd></dl>

<div class="section" id="instances">
<h3>Instances<a class="headerlink" href="#instances" title="Permalink to this headline">¶</a></h3>
<p>Ceres includes a number of predefined loss functions. For simplicity
we described their unscaled versions. The figure below illustrates
their shape graphically. More details can be found in
<code class="docutils literal"><span class="pre">include/ceres/loss_function.h</span></code>.</p>
<div class="figure align-center" id="id5" style="width: 500px">
<a class="reference internal image-reference" href="_images/loss.png"><img alt="_images/loss.png" src="_images/loss.png" style="height: 400px;" /></a>
<p class="caption"><span class="caption-text">Shape of the various common loss functions.</span></p>
</div>
<dl class="class">
<dt id="_CPPv2N5ceres11TrivialLossE">
<span id="ceres::TrivialLoss"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">TrivialLoss</code><a class="headerlink" href="#_CPPv2N5ceres11TrivialLossE" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = s\]</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres9HuberLossE">
<span id="ceres::HuberLoss"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">HuberLoss</code><a class="headerlink" href="#_CPPv2N5ceres9HuberLossE" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\begin{split}\rho(s) = \begin{cases} s &amp; s \le 1\\ 2 \sqrt{s} - 1 &amp; s &gt; 1 \end{cases}\end{split}\]</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres12SoftLOneLossE">
<span id="ceres::SoftLOneLoss"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">SoftLOneLoss</code><a class="headerlink" href="#_CPPv2N5ceres12SoftLOneLossE" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = 2 (\sqrt{1+s} - 1)\]</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres10CauchyLossE">
<span id="ceres::CauchyLoss"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">CauchyLoss</code><a class="headerlink" href="#_CPPv2N5ceres10CauchyLossE" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = \log(1 + s)\]</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres10ArctanLossE">
<span id="ceres::ArctanLoss"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">ArctanLoss</code><a class="headerlink" href="#_CPPv2N5ceres10ArctanLossE" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = \arctan(s)\]</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres12TolerantLossE">
<span id="ceres::TolerantLoss"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">TolerantLoss</code><a class="headerlink" href="#_CPPv2N5ceres12TolerantLossE" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s,a,b) = b \log(1 + e^{(s - a) / b}) - b \log(1 + e^{-a / b})\]</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres12ComposedLossE">
<span id="ceres::ComposedLoss"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">ComposedLoss</code><a class="headerlink" href="#_CPPv2N5ceres12ComposedLossE" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two loss functions <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">g</span></code>, implements the loss
function <code class="docutils literal"><span class="pre">h(s)</span> <span class="pre">=</span> <span class="pre">f(g(s))</span></code>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ComposedLoss</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LossFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">ComposedLoss</span><span class="p">(</span><span class="k">const</span> <span class="n">LossFunction</span><span class="o">*</span> <span class="n">f</span><span class="p">,</span>
                        <span class="n">Ownership</span> <span class="n">ownership_f</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">LossFunction</span><span class="o">*</span> <span class="n">g</span><span class="p">,</span>
                        <span class="n">Ownership</span> <span class="n">ownership_g</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres10ScaledLossE">
<span id="ceres::ScaledLoss"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">ScaledLoss</code><a class="headerlink" href="#_CPPv2N5ceres10ScaledLossE" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes you want to simply scale the output value of the
robustifier. For example, you might want to weight different error
terms differently (e.g., weight pixel reprojection errors
differently from terrain errors).</p>
<p>Given a loss function <span class="math">\(\rho(s)\)</span> and a scalar <span class="math">\(a\)</span>, <a class="reference internal" href="#_CPPv2N5ceres10ScaledLossE" title="ceres::ScaledLoss"><code class="xref cpp cpp-class docutils literal"><span class="pre">ScaledLoss</span></code></a>
implements the function <span class="math">\(a \rho(s)\)</span>.</p>
<p>Since we treat a <code class="docutils literal"><span class="pre">NULL</span></code> Loss function as the Identity loss
function, <span class="math">\(rho\)</span> = <code class="docutils literal"><span class="pre">NULL</span></code>: is a valid input and will result
in the input being scaled by <span class="math">\(a\)</span>. This provides a simple way
of implementing a scaled ResidualBlock.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres19LossFunctionWrapperE">
<span id="ceres::LossFunctionWrapper"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">LossFunctionWrapper</code><a class="headerlink" href="#_CPPv2N5ceres19LossFunctionWrapperE" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes after the optimization problem has been constructed, we
wish to mutate the scale of the loss function. For example, when
performing estimation from data which has substantial outliers,
convergence can be improved by starting out with a large scale,
optimizing the problem and then reducing the scale. This can have
better convergence behavior than just using a loss function with a
small scale.</p>
<p>This templated class allows the user to implement a loss function
whose scale can be mutated after an optimization problem has been
constructed, e.g,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>

<span class="c1">// Add parameter blocks</span>

<span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">AutoDiffCostFunction</span> <span class="o">&lt;</span> <span class="n">UW_Camera_Mapper</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">UW_Camera_Mapper</span><span class="p">(</span><span class="n">feature_x</span><span class="p">,</span> <span class="n">feature_y</span><span class="p">));</span>

<span class="n">LossFunctionWrapper</span><span class="o">*</span> <span class="nf">loss_function</span><span class="p">(</span><span class="k">new</span> <span class="n">HuberLoss</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">TAKE_OWNERSHIP</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="n">loss_function</span><span class="p">,</span> <span class="n">parameters</span><span class="p">);</span>

<span class="n">Solver</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
<span class="n">Solver</span><span class="o">::</span><span class="n">Summary</span> <span class="n">summary</span><span class="p">;</span>
<span class="n">Solve</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">problem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>

<span class="n">loss_function</span><span class="o">-&gt;</span><span class="n">Reset</span><span class="p">(</span><span class="k">new</span> <span class="n">HuberLoss</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">TAKE_OWNERSHIP</span><span class="p">);</span>
<span class="n">Solve</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">problem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="theory">
<h3>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h3>
<p>Let us consider a problem with a single problem and a single parameter
block.</p>
<div class="math">
\[\min_x \frac{1}{2}\rho(f^2(x))\]</div>
<p>Then, the robustified gradient and the Gauss-Newton Hessian are</p>
<div class="math">
\[\begin{split}g(x) &amp;= \rho'J^\top(x)f(x)\\
H(x) &amp;= J^\top(x)\left(\rho' + 2 \rho''f(x)f^\top(x)\right)J(x)\end{split}\]</div>
<p>where the terms involving the second derivatives of <span class="math">\(f(x)\)</span> have
been ignored. Note that <span class="math">\(H(x)\)</span> is indefinite if
<span class="math">\(\rho''f(x)^\top f(x) + \frac{1}{2}\rho' &lt; 0\)</span>. If this is not
the case, then its possible to re-weight the residual and the Jacobian
matrix such that the corresponding linear least squares problem for
the robustified Gauss-Newton step.</p>
<p>Let <span class="math">\(\alpha\)</span> be a root of</p>
<div class="math">
\[\frac{1}{2}\alpha^2 - \alpha - \frac{\rho''}{\rho'}\|f(x)\|^2 = 0.\]</div>
<p>Then, define the rescaled residual and Jacobian as</p>
<div class="math">
\[\begin{split}\tilde{f}(x) &amp;= \frac{\sqrt{\rho'}}{1 - \alpha} f(x)\\
\tilde{J}(x) &amp;= \sqrt{\rho'}\left(1 - \alpha
                \frac{f(x)f^\top(x)}{\left\|f(x)\right\|^2} \right)J(x)\end{split}\]</div>
<p>In the case <span class="math">\(2 \rho''\left\|f(x)\right\|^2 + \rho' \lesssim 0\)</span>,
we limit <span class="math">\(\alpha \le 1- \epsilon\)</span> for some small
<span class="math">\(\epsilon\)</span>. For more details see <a class="reference internal" href="bibliography.html#triggs" id="id1">[Triggs]</a>.</p>
<p>With this simple rescaling, one can use any Jacobian based non-linear
least squares algorithm to robustified non-linear least squares
problems.</p>
</div>
</div>
<div class="section" id="localparameterization">
<h2><a class="reference internal" href="#_CPPv2N5ceres21LocalParameterizationE" title="ceres::LocalParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></code></a><a class="headerlink" href="#localparameterization" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres21LocalParameterizationE">
<span id="ceres::LocalParameterization"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">LocalParameterization</code><a class="headerlink" href="#_CPPv2N5ceres21LocalParameterizationE" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LocalParameterization</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">LocalParameterization</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Plus</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span>
                    <span class="kt">double</span><span class="o">*</span> <span class="n">x_plus_delta</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">ComputeJacobian</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">jacobian</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">MultiplyByJacobian</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="kt">int</span> <span class="n">num_rows</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">global_matrix</span><span class="p">,</span>
                                  <span class="kt">double</span><span class="o">*</span> <span class="n">local_matrix</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">GlobalSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">LocalSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Sometimes the parameters <span class="math">\(x\)</span> can overparameterize a
problem. In that case it is desirable to choose a parameterization
to remove the null directions of the cost. More generally, if
<span class="math">\(x\)</span> lies on a manifold of a smaller dimension than the
ambient space that it is embedded in, then it is numerically and
computationally more effective to optimize it using a
parameterization that lives in the tangent space of that manifold
at each point.</p>
<p>For example, a sphere in three dimensions is a two dimensional
manifold, embedded in a three dimensional space. At each point on
the sphere, the plane tangent to it defines a two dimensional
tangent space. For a cost function defined on this sphere, given a
point <span class="math">\(x\)</span>, moving in the direction normal to the sphere at
that point is not useful. Thus a better way to parameterize a point
on a sphere is to optimize over two dimensional vector
<span class="math">\(\Delta x\)</span> in the tangent space at the point on the sphere
point and then &#8220;move&#8221; to the point <span class="math">\(x + \Delta x\)</span>, where the
move operation involves projecting back onto the sphere. Doing so
removes a redundant dimension from the optimization, making it
numerically more robust and efficient.</p>
<p>More generally we can define a function</p>
<div class="math">
\[x' = \boxplus(x, \Delta x),\]</div>
<p>where <span class="math">\(x'\)</span> has the same size as <span class="math">\(x\)</span>, and <span class="math">\(\Delta
x\)</span> is of size less than or equal to <span class="math">\(x\)</span>. The function
<span class="math">\(\boxplus\)</span>, generalizes the definition of vector
addition. Thus it satisfies the identity</p>
<div class="math">
\[\boxplus(x, 0) = x,\quad \forall x.\]</div>
<p>Instances of <a class="reference internal" href="#_CPPv2N5ceres21LocalParameterizationE" title="ceres::LocalParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></code></a> implement the
<span class="math">\(\boxplus\)</span> operation and its derivative with respect to
<span class="math">\(\Delta x\)</span> at <span class="math">\(\Delta x = 0\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres21LocalParameterization10GlobalSizeEv">
<span id="ceres::LocalParameterization::GlobalSize"></span>int <code class="descclassname">LocalParameterization::</code><code class="descname">GlobalSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres21LocalParameterization10GlobalSizeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of the ambient space in which the parameter block
<span class="math">\(x\)</span> lives.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres21LocalParameterization9LocalSizeEv">
<span id="ceres::LocalParameterization::LocalSize"></span>int <code class="descclassname">LocalParameterization::</code><code class="descname">LocalSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres21LocalParameterization9LocalSizeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the tangent space
that <span class="math">\(\Delta x\)</span> lives in.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres21LocalParameterization4PlusEPKdPKdPd">
<span id="ceres::LocalParameterization::Plus__doubleCP.doubleCP.doublePC"></span>bool <code class="descclassname">LocalParameterization::</code><code class="descname">Plus</code><span class="sig-paren">(</span><em class="property">const</em> double *<em>x</em>, <em class="property">const</em> double *<em>delta</em>, double *<em>x_plus_delta</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres21LocalParameterization4PlusEPKdPKdPd" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#_CPPv2NK5ceres21LocalParameterization4PlusEPKdPKdPd" title="ceres::LocalParameterization::Plus"><code class="xref cpp cpp-func docutils literal"><span class="pre">LocalParameterization::Plus()</span></code></a> implements <span class="math">\(\boxplus(x,\Delta x)\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres21LocalParameterization15ComputeJacobianEPKdPd">
<span id="ceres::LocalParameterization::ComputeJacobian__doubleCP.doublePC"></span>bool <code class="descclassname">LocalParameterization::</code><code class="descname">ComputeJacobian</code><span class="sig-paren">(</span><em class="property">const</em> double *<em>x</em>, double *<em>jacobian</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres21LocalParameterization15ComputeJacobianEPKdPd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Jacobian matrix</p>
<div class="math">
\[J = \left . \frac{\partial }{\partial \Delta x} \boxplus(x,\Delta x)\right|_{\Delta x = 0}\]</div>
<p>in row major form.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres18MultiplyByJacobianEPKdKiPKdPd">
<span id="ceres::MultiplyByJacobian__doubleCP.iC.doubleCP.doublePC"></span>bool <code class="descclassname"></code><code class="descname">MultiplyByJacobian</code><span class="sig-paren">(</span><em class="property">const</em> double *<em>x</em>, <em class="property">const</em> int <em>num_rows</em>, <em class="property">const</em> double *<em>global_matrix</em>, double *<em>local_matrix</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres18MultiplyByJacobianEPKdKiPKdPd" title="Permalink to this definition">¶</a></dt>
<dd><p>local_matrix = global_matrix * jacobian</p>
<p>global_matrix is a num_rows x GlobalSize  row major matrix.
local_matrix is a num_rows x LocalSize row major matrix.
jacobian is the matrix returned by <a class="reference internal" href="#_CPPv2NK5ceres21LocalParameterization15ComputeJacobianEPKdPd" title="ceres::LocalParameterization::ComputeJacobian"><code class="xref cpp cpp-func docutils literal"><span class="pre">LocalParameterization::ComputeJacobian()</span></code></a> at <span class="math">\(x\)</span>.</p>
<p>This is only used by GradientProblem. For most normal uses, it is
okay to use the default implementation.</p>
</dd></dl>

<div class="section" id="id2">
<h3>Instances<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv2N5ceres24IdentityParameterizationE">
<span id="ceres::IdentityParameterization"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">IdentityParameterization</code><a class="headerlink" href="#_CPPv2N5ceres24IdentityParameterizationE" title="Permalink to this definition">¶</a></dt>
<dd><p>A trivial version of <span class="math">\(\boxplus\)</span> is when <span class="math">\(\Delta x\)</span> is
of the same size as <span class="math">\(x\)</span> and</p>
<div class="math">
\[\boxplus(x, \Delta x) = x + \Delta x\]</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres22SubsetParameterizationE">
<span id="ceres::SubsetParameterization"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">SubsetParameterization</code><a class="headerlink" href="#_CPPv2N5ceres22SubsetParameterizationE" title="Permalink to this definition">¶</a></dt>
<dd><p>A more interesting case if <span class="math">\(x\)</span> is a two dimensional vector,
and the user wishes to hold the first coordinate constant. Then,
<span class="math">\(\Delta x\)</span> is a scalar and <span class="math">\(\boxplus\)</span> is defined as</p>
<div class="math">
\[\begin{split}\boxplus(x, \Delta x) = x + \left[ \begin{array}{c} 0 \\ 1
                            \end{array} \right] \Delta x\end{split}\]</div>
<p><a class="reference internal" href="#_CPPv2N5ceres22SubsetParameterizationE" title="ceres::SubsetParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">SubsetParameterization</span></code></a> generalizes this construction to
hold any part of a parameter block constant.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres26QuaternionParameterizationE">
<span id="ceres::QuaternionParameterization"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">QuaternionParameterization</code><a class="headerlink" href="#_CPPv2N5ceres26QuaternionParameterizationE" title="Permalink to this definition">¶</a></dt>
<dd><p>Another example that occurs commonly in Structure from Motion
problems is when camera rotations are parameterized using a
quaternion. There, it is useful only to make updates orthogonal to
that 4-vector defining the quaternion. One way to do this is to let
<span class="math">\(\Delta x\)</span> be a 3 dimensional vector and define
<span class="math">\(\boxplus\)</span> to be</p>
<blockquote>
<div><div class="math" id="equation-quaternion">
<span class="eqno">(3)</span>\[\boxplus(x, \Delta x) = \left[ \cos(|\Delta x|), \frac{\sin\left(|\Delta x|\right)}{|\Delta x|} \Delta x \right] * x\]</div>
</div></blockquote>
<p>The multiplication between the two 4-vectors on the right hand side
is the standard quaternion
product. <a class="reference internal" href="#_CPPv2N5ceres26QuaternionParameterizationE" title="ceres::QuaternionParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">QuaternionParameterization</span></code></a> is an implementation
of <a href="#equation-quaternion">(3)</a>.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres31EigenQuaternionParameterizationE">
<span id="ceres::EigenQuaternionParameterization"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">EigenQuaternionParameterization</code><a class="headerlink" href="#_CPPv2N5ceres31EigenQuaternionParameterizationE" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigen uses a different internal memory layout for the elements of the
quaternion than what is commonly used. Specifically, Eigen stores the
elements in memory as [x, y, z, w] where the real part is last
whereas it is typically stored first. Note, when creating an Eigen
quaternion through the constructor the elements are accepted in w, x,
y, z order. Since Ceres operates on parameter blocks which are raw
double pointers this difference is important and requires a different
parameterization. <a class="reference internal" href="#_CPPv2N5ceres31EigenQuaternionParameterizationE" title="ceres::EigenQuaternionParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">EigenQuaternionParameterization</span></code></a> uses the
same update as <a class="reference internal" href="#_CPPv2N5ceres26QuaternionParameterizationE" title="ceres::QuaternionParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">QuaternionParameterization</span></code></a> but takes into
account Eigen&#8217;s internal memory element ordering.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres33HomogeneousVectorParameterizationE">
<span id="ceres::HomogeneousVectorParameterization"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">HomogeneousVectorParameterization</code><a class="headerlink" href="#_CPPv2N5ceres33HomogeneousVectorParameterizationE" title="Permalink to this definition">¶</a></dt>
<dd><p>In computer vision, homogeneous vectors are commonly used to
represent entities in projective geometry such as points in
projective space. One example where it is useful to use this
over-parameterization is in representing points whose triangulation
is ill-conditioned. Here it is advantageous to use homogeneous
vectors, instead of an Euclidean vector, because it can represent
points at infinity.</p>
<p>When using homogeneous vectors it is useful to only make updates
orthogonal to that <span class="math">\(n\)</span>-vector defining the homogeneous
vector <a class="reference internal" href="bibliography.html#hartleyzisserman" id="id3">[HartleyZisserman]</a>. One way to do this is to let <span class="math">\(\Delta x\)</span>
be a <span class="math">\(n-1\)</span> dimensional vector and define <span class="math">\(\boxplus\)</span> to be</p>
<blockquote>
<div><div class="math">
\[\boxplus(x, \Delta x) = \left[ \frac{\sin\left(0.5 |\Delta x|\right)}{|\Delta x|} \Delta x, \cos(0.5 |\Delta x|) \right] * x\]</div>
</div></blockquote>
<p>The multiplication between the two vectors on the right hand side
is defined as an operator which applies the update orthogonal to
<span class="math">\(x\)</span> to remain on the sphere. Note, it is assumed that
last element of <span class="math">\(x\)</span> is the scalar component of the homogeneous
vector.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres23ProductParameterizationE">
<span id="ceres::ProductParameterization"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">ProductParameterization</code><a class="headerlink" href="#_CPPv2N5ceres23ProductParameterizationE" title="Permalink to this definition">¶</a></dt>
<dd><p>Consider an optimization problem over the space of rigid
transformations <span class="math">\(SE(3)\)</span>, which is the Cartesian product of
<span class="math">\(SO(3)\)</span> and <span class="math">\(\mathbb{R}^3\)</span>. Suppose you are using
Quaternions to represent the rotation, Ceres ships with a local
parameterization for that and <span class="math">\(\mathbb{R}^3\)</span> requires no, or
<a class="reference internal" href="#_CPPv2N5ceres24IdentityParameterizationE" title="ceres::IdentityParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">IdentityParameterization</span></code></a> parameterization. So how do we
construct a local parameterization for a parameter block a rigid
transformation?</p>
<p>In cases, where a parameter block is the Cartesian product of a
number of manifolds and you have the local parameterization of the
individual manifolds available, <a class="reference internal" href="#_CPPv2N5ceres23ProductParameterizationE" title="ceres::ProductParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">ProductParameterization</span></code></a>
can be used to construct a local parameterization of the cartesian
product. For the case of the rigid transformation, where say you
have a parameter block of size 7, where the first four entries
represent the rotation as a quaternion, a local parameterization
can be constructed as</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ProductParameterization</span> <span class="nf">se3_param</span><span class="p">(</span><span class="k">new</span> <span class="n">QuaternionParameterization</span><span class="p">(),</span>
                                  <span class="k">new</span> <span class="n">IdentityTransformation</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="autodifflocalparameterization">
<h2><a class="reference internal" href="#_CPPv2N5ceres29AutoDiffLocalParameterizationE" title="ceres::AutoDiffLocalParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffLocalParameterization</span></code></a><a class="headerlink" href="#autodifflocalparameterization" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres29AutoDiffLocalParameterizationE">
<span id="ceres::AutoDiffLocalParameterization"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">AutoDiffLocalParameterization</code><a class="headerlink" href="#_CPPv2N5ceres29AutoDiffLocalParameterizationE" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#_CPPv2N5ceres29AutoDiffLocalParameterizationE" title="ceres::AutoDiffLocalParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffLocalParameterization</span></code></a> does for
<a class="reference internal" href="#_CPPv2N5ceres21LocalParameterizationE" title="ceres::LocalParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></code></a> what <a class="reference internal" href="#_CPPv2N5ceres20AutoDiffCostFunctionE" title="ceres::AutoDiffCostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></code></a>
does for <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a>. It allows the user to define a
templated functor that implements the
<a class="reference internal" href="#_CPPv2NK5ceres21LocalParameterization4PlusEPKdPKdPd" title="ceres::LocalParameterization::Plus"><code class="xref cpp cpp-func docutils literal"><span class="pre">LocalParameterization::Plus()</span></code></a> operation and it uses automatic
differentiation to implement the computation of the Jacobian.</p>
<p>To get an auto differentiated local parameterization, you must
define a class with a templated operator() (a functor) that computes</p>
<blockquote>
<div><div class="math">
\[x' = \boxplus(x, \Delta x),\]</div>
</div></blockquote>
<p>For example, Quaternions have a three dimensional local
parameterization. Its plus operation can be implemented as (taken
from <a class="reference external" href="https://ceres-solver.googlesource.com/ceres-solver/+/master/internal/ceres/autodiff_local_parameterization_test.cc">internal/ceres/autodiff_local_parameterization_test.cc</a>
)</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">QuaternionPlus</span> <span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">x_plus_delta</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">squared_norm_delta</span> <span class="o">=</span>
        <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">T</span> <span class="n">q_delta</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">squared_norm_delta</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">T</span> <span class="n">norm_delta</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">squared_norm_delta</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">T</span> <span class="n">sin_delta_by_delta</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">norm_delta</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm_delta</span><span class="p">;</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">norm_delta</span><span class="p">);</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_delta_by_delta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_delta_by_delta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_delta_by_delta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// We do not just use q_delta = [1,0,0,0] here because that is a</span>
      <span class="c1">// constant and when used for automatic differentiation will</span>
      <span class="c1">// lead to a zero derivative. Instead we take a first order</span>
      <span class="c1">// approximation and evaluate it at zero.</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">Quaternionproduct</span><span class="p">(</span><span class="n">q_delta</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x_plus_delta</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>Given this struct, the auto differentiated local
parameterization can now be constructed as</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">LocalParameterization</span><span class="o">*</span> <span class="n">local_parameterization</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">AutoDiffLocalParameterization</span><span class="o">&lt;</span><span class="n">QuaternionPlus</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
                                                      <span class="o">|</span>  <span class="o">|</span>
                           <span class="n">Global</span> <span class="n">Size</span> <span class="o">---------------+</span>  <span class="o">|</span>
                           <span class="n">Local</span> <span class="n">Size</span> <span class="o">-------------------+</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="problem">
<h2><a class="reference internal" href="#_CPPv2N5ceres7ProblemE" title="ceres::Problem"><code class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></code></a><a class="headerlink" href="#problem" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N5ceres7ProblemE">
<span id="ceres::Problem"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">Problem</code><a class="headerlink" href="#_CPPv2N5ceres7ProblemE" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#_CPPv2N5ceres7ProblemE" title="ceres::Problem"><code class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></code></a> holds the robustified bounds constrained
non-linear least squares problem <a href="#equation-ceresproblem">(1)</a>. To create a
least squares problem, use the <a class="reference internal" href="#_CPPv2N5ceres7Problem16AddResidualBlockEP12CostFunctionP12LossFunctionK6vectorIPdE" title="ceres::Problem::AddResidualBlock"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></code></a>
and <a class="reference internal" href="#_CPPv2N5ceres7Problem17AddParameterBlockEPdiP21LocalParameterization" title="ceres::Problem::AddParameterBlock"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></code></a> methods.</p>
<p>For example a problem containing 3 parameter blocks of sizes 3, 4
and 5 respectively and two residual blocks of size 2 and 6:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">x1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">};</span>
<span class="kt">double</span> <span class="n">x2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span> <span class="p">};</span>
<span class="kt">double</span> <span class="n">x3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">7.0</span> <span class="p">};</span>

<span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyUnaryCostFunction</span><span class="p">(...),</span> <span class="n">x1</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyBinaryCostFunction</span><span class="p">(...),</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#_CPPv2N5ceres7Problem16AddResidualBlockEP12CostFunctionP12LossFunctionK6vectorIPdE" title="ceres::Problem::AddResidualBlock"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></code></a> as the name implies, adds a
residual block to the problem. It adds a <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a>, an
optional <a class="reference internal" href="#_CPPv2N5ceres12LossFunctionE" title="ceres::LossFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></code></a> and connects the
<a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> to a set of parameter block.</p>
<p>The cost function carries with it information about the sizes of
the parameter blocks it expects. The function checks that these
match the sizes of the parameter blocks listed in
<code class="docutils literal"><span class="pre">parameter_blocks</span></code>. The program aborts if a mismatch is
detected. <code class="docutils literal"><span class="pre">loss_function</span></code> can be <code class="docutils literal"><span class="pre">NULL</span></code>, in which case the cost
of the term is just the squared norm of the residuals.</p>
<p>The user has the option of explicitly adding the parameter blocks
using <a class="reference internal" href="#_CPPv2N5ceres7Problem17AddParameterBlockEPdiP21LocalParameterization" title="ceres::Problem::AddParameterBlock"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></code></a>. This causes additional
correctness checking; however, <a class="reference internal" href="#_CPPv2N5ceres7Problem16AddResidualBlockEP12CostFunctionP12LossFunctionK6vectorIPdE" title="ceres::Problem::AddResidualBlock"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></code></a>
implicitly adds the parameter blocks if they are not present, so
calling <a class="reference internal" href="#_CPPv2N5ceres7Problem17AddParameterBlockEPdiP21LocalParameterization" title="ceres::Problem::AddParameterBlock"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></code></a> explicitly is not
required.</p>
<p><a class="reference internal" href="#_CPPv2N5ceres7Problem17AddParameterBlockEPdiP21LocalParameterization" title="ceres::Problem::AddParameterBlock"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></code></a> explicitly adds a parameter
block to the <a class="reference internal" href="#_CPPv2N5ceres7ProblemE" title="ceres::Problem"><code class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></code></a>. Optionally it allows the user to
associate a <a class="reference internal" href="#_CPPv2N5ceres21LocalParameterizationE" title="ceres::LocalParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></code></a> object with the
parameter block too. Repeated calls with the same arguments are
ignored. Repeated calls with the same double pointer but a
different size results in undefined behavior.</p>
<p>You can set any parameter block to be constant using
<a class="reference internal" href="#_CPPv2N5ceres7Problem25SetParameterBlockConstantEPd" title="ceres::Problem::SetParameterBlockConstant"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::SetParameterBlockConstant()</span></code></a> and undo this using
<a class="reference internal" href="#_CPPv2N5ceres7Problem25SetParameterBlockVariableEPd" title="ceres::Problem::SetParameterBlockVariable"><code class="xref cpp cpp-func docutils literal"><span class="pre">SetParameterBlockVariable()</span></code></a>.</p>
<p>In fact you can set any number of parameter blocks to be constant,
and Ceres is smart enough to figure out what part of the problem
you have constructed depends on the parameter blocks that are free
to change and only spends time solving it. So for example if you
constructed a problem with a million parameter blocks and 2 million
residual blocks, but then set all but one parameter blocks to be
constant and say only 10 residual blocks depend on this one
non-constant parameter block. Then the computational effort Ceres
spends in solving this problem will be the same if you had defined
a problem with one parameter block and 10 residual blocks.</p>
<p><strong>Ownership</strong></p>
<p><a class="reference internal" href="#_CPPv2N5ceres7ProblemE" title="ceres::Problem"><code class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></code></a> by default takes ownership of the
<code class="docutils literal"><span class="pre">cost_function</span></code>, <code class="docutils literal"><span class="pre">loss_function</span></code> and <code class="docutils literal"><span class="pre">local_parameterization</span></code>
pointers. These objects remain live for the life of the
<a class="reference internal" href="#_CPPv2N5ceres7ProblemE" title="ceres::Problem"><code class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></code></a>. If the user wishes to keep control over the
destruction of these objects, then they can do this by setting the
corresponding enums in the <code class="xref cpp cpp-class docutils literal"><span class="pre">Problem::Options</span></code> struct.</p>
<p>Note that even though the Problem takes ownership of <code class="docutils literal"><span class="pre">cost_function</span></code>
and <code class="docutils literal"><span class="pre">loss_function</span></code>, it does not preclude the user from re-using
them in another residual block. The destructor takes care to call
delete on each <code class="docutils literal"><span class="pre">cost_function</span></code> or <code class="docutils literal"><span class="pre">loss_function</span></code> pointer only
once, regardless of how many residual blocks refer to them.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem16AddResidualBlockEP12CostFunctionP12LossFunctionK6vectorIPdE">
<span id="ceres::Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C"></span>ResidualBlockId <code class="descclassname">Problem::</code><code class="descname">AddResidualBlock</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction">CostFunction</a> *<em>cost_function</em>, <a class="reference internal" href="#_CPPv2N5ceres12LossFunctionE" title="ceres::LossFunction">LossFunction</a> *<em>loss_function</em>, <em class="property">const</em> vector&lt;double *&gt; <em>parameter_blocks</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem16AddResidualBlockEP12CostFunctionP12LossFunctionK6vectorIPdE" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a residual block to the overall cost function. The cost
function carries with it information about the sizes of the
parameter blocks it expects. The function checks that these match
the sizes of the parameter blocks listed in parameter_blocks. The
program aborts if a mismatch is detected. loss_function can be
NULL, in which case the cost of the term is just the squared norm
of the residuals.</p>
<p>The user has the option of explicitly adding the parameter blocks
using AddParameterBlock. This causes additional correctness
checking; however, AddResidualBlock implicitly adds the parameter
blocks if they are not present, so calling AddParameterBlock
explicitly is not required.</p>
<p>The Problem object by default takes ownership of the
cost_function and loss_function pointers. These objects remain
live for the life of the Problem object. If the user wishes to
keep control over the destruction of these objects, then they can
do this by setting the corresponding enums in the Options struct.</p>
<p>Note: Even though the Problem takes ownership of cost_function
and loss_function, it does not preclude the user from re-using
them in another residual block. The destructor takes care to call
delete on each cost_function or loss_function pointer only once,
regardless of how many residual blocks refer to them.</p>
<p>Example usage:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">x1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">};</span>
<span class="kt">double</span> <span class="n">x2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">};</span>
<span class="kt">double</span> <span class="n">x3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">};</span>

<span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>

<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyUnaryCostFunction</span><span class="p">(...),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyBinaryCostFunction</span><span class="p">(...),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem17AddParameterBlockEPdiP21LocalParameterization">
<span id="ceres::Problem::AddParameterBlock__doubleP.i.LocalParameterizationP"></span>void <code class="descclassname">Problem::</code><code class="descname">AddParameterBlock</code><span class="sig-paren">(</span>double *<em>values</em>, int <em>size</em>, <a class="reference internal" href="#_CPPv2N5ceres21LocalParameterizationE" title="ceres::LocalParameterization">LocalParameterization</a> *<em>local_parameterization</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem17AddParameterBlockEPdiP21LocalParameterization" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a parameter block with appropriate size to the problem.
Repeated calls with the same arguments are ignored. Repeated calls
with the same double pointer but a different size results in
undefined behavior.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem17AddParameterBlockEPdi">
<span id="ceres::Problem::AddParameterBlock__doubleP.i"></span>void <code class="descclassname">Problem::</code><code class="descname">AddParameterBlock</code><span class="sig-paren">(</span>double *<em>values</em>, int <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem17AddParameterBlockEPdi" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a parameter block with appropriate size and parameterization to
the problem. Repeated calls with the same arguments are
ignored. Repeated calls with the same double pointer but a
different size results in undefined behavior.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem19RemoveResidualBlockE15ResidualBlockId">
<span id="ceres::Problem::RemoveResidualBlock__ResidualBlockId"></span>void <code class="descclassname">Problem::</code><code class="descname">RemoveResidualBlock</code><span class="sig-paren">(</span>ResidualBlockId <em>residual_block</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem19RemoveResidualBlockE15ResidualBlockId" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a residual block from the problem. Any parameters that the residual
block depends on are not removed. The cost and loss functions for the
residual block will not get deleted immediately; won&#8217;t happen until the
problem itself is deleted.  If Problem::Options::enable_fast_removal is
true, then the removal is fast (almost constant time). Otherwise, removing a
residual block will incur a scan of the entire Problem object to verify that
the residual_block represents a valid residual in the problem.</p>
<p><strong>WARNING:</strong> Removing a residual or parameter block will destroy
the implicit ordering, rendering the jacobian or residuals returned
from the solver uninterpretable. If you depend on the evaluated
jacobian, do not use remove! This may change in a future release.
Hold the indicated parameter block constant during optimization.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem20RemoveParameterBlockEPd">
<span id="ceres::Problem::RemoveParameterBlock__doubleP"></span>void <code class="descclassname">Problem::</code><code class="descname">RemoveParameterBlock</code><span class="sig-paren">(</span>double *<em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem20RemoveParameterBlockEPd" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a parameter block from the problem. The parameterization of
the parameter block, if it exists, will persist until the deletion
of the problem (similar to cost/loss functions in residual block
removal). Any residual blocks that depend on the parameter are also
removed, as described above in RemoveResidualBlock().  If
Problem::Options::enable_fast_removal is true, then
the removal is fast (almost constant time). Otherwise, removing a
parameter block will incur a scan of the entire Problem object.</p>
<p><strong>WARNING:</strong> Removing a residual or parameter block will destroy
the implicit ordering, rendering the jacobian or residuals returned
from the solver uninterpretable. If you depend on the evaluated
jacobian, do not use remove! This may change in a future release.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem25SetParameterBlockConstantEPd">
<span id="ceres::Problem::SetParameterBlockConstant__doubleP"></span>void <code class="descclassname">Problem::</code><code class="descname">SetParameterBlockConstant</code><span class="sig-paren">(</span>double *<em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem25SetParameterBlockConstantEPd" title="Permalink to this definition">¶</a></dt>
<dd><p>Hold the indicated parameter block constant during optimization.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem25SetParameterBlockVariableEPd">
<span id="ceres::Problem::SetParameterBlockVariable__doubleP"></span>void <code class="descclassname">Problem::</code><code class="descname">SetParameterBlockVariable</code><span class="sig-paren">(</span>double *<em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem25SetParameterBlockVariableEPd" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the indicated parameter to vary during optimization.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem19SetParameterizationEPdP21LocalParameterization">
<span id="ceres::Problem::SetParameterization__doubleP.LocalParameterizationP"></span>void <code class="descclassname">Problem::</code><code class="descname">SetParameterization</code><span class="sig-paren">(</span>double *<em>values</em>, <a class="reference internal" href="#_CPPv2N5ceres21LocalParameterizationE" title="ceres::LocalParameterization">LocalParameterization</a> *<em>local_parameterization</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem19SetParameterizationEPdP21LocalParameterization" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the local parameterization for one of the parameter blocks.
The local_parameterization is owned by the Problem by default. It
is acceptable to set the same parameterization for multiple
parameters; the destructor is careful to delete local
parameterizations only once. The local parameterization can only be
set once per parameter, and cannot be changed once set.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem19GetParameterizationEPd">
<span id="ceres::Problem::GetParameterization__doublePC"></span><a class="reference internal" href="#_CPPv2N5ceres21LocalParameterizationE" title="ceres::LocalParameterization">LocalParameterization</a> *<code class="descclassname">Problem::</code><code class="descname">GetParameterization</code><span class="sig-paren">(</span>double *<em>values</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem19GetParameterizationEPd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the local parameterization object associated with this
parameter block. If there is no parameterization object associated
then <cite>NULL</cite> is returned</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem22SetParameterLowerBoundEPdid">
<span id="ceres::Problem::SetParameterLowerBound__doubleP.i.double"></span>void <code class="descclassname">Problem::</code><code class="descname">SetParameterLowerBound</code><span class="sig-paren">(</span>double *<em>values</em>, int <em>index</em>, double <em>lower_bound</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem22SetParameterLowerBoundEPdid" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the lower bound for the parameter at position <cite>index</cite> in the
parameter block corresponding to <cite>values</cite>. By default the lower
bound is <span class="math">\(-\infty\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem22SetParameterUpperBoundEPdid">
<span id="ceres::Problem::SetParameterUpperBound__doubleP.i.double"></span>void <code class="descclassname">Problem::</code><code class="descname">SetParameterUpperBound</code><span class="sig-paren">(</span>double *<em>values</em>, int <em>index</em>, double <em>upper_bound</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem22SetParameterUpperBoundEPdid" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the upper bound for the parameter at position <cite>index</cite> in the
parameter block corresponding to <cite>values</cite>. By default the value is
<span class="math">\(\infty\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem18NumParameterBlocksEv">
<span id="ceres::Problem::NumParameterBlocksC"></span>int <code class="descclassname">Problem::</code><code class="descname">NumParameterBlocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem18NumParameterBlocksEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of parameter blocks in the problem. Always equals
parameter_blocks().size() and parameter_block_sizes().size().</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem13NumParametersEv">
<span id="ceres::Problem::NumParametersC"></span>int <code class="descclassname">Problem::</code><code class="descname">NumParameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem13NumParametersEv" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the parameter vector obtained by summing over the sizes
of all the parameter blocks.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem17NumResidualBlocksEv">
<span id="ceres::Problem::NumResidualBlocksC"></span>int <code class="descclassname">Problem::</code><code class="descname">NumResidualBlocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem17NumResidualBlocksEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of residual blocks in the problem. Always equals
residual_blocks().size().</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem12NumResidualsEv">
<span id="ceres::Problem::NumResidualsC"></span>int <code class="descclassname">Problem::</code><code class="descname">NumResiduals</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem12NumResidualsEv" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the residual vector obtained by summing over the sizes
of all of the residual blocks.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem18ParameterBlockSizeEPKd">
<span id="ceres::Problem::ParameterBlockSize__doubleCPC"></span>int <code class="descclassname">Problem::</code><code class="descname">ParameterBlockSize</code><span class="sig-paren">(</span><em class="property">const</em> double *<em>values</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem18ParameterBlockSizeEPKd" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the parameter block.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem23ParameterBlockLocalSizeEPKd">
<span id="ceres::Problem::ParameterBlockLocalSize__doubleCPC"></span>int <code class="descclassname">Problem::</code><code class="descname">ParameterBlockLocalSize</code><span class="sig-paren">(</span><em class="property">const</em> double *<em>values</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem23ParameterBlockLocalSizeEPKd" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of local parameterization for the parameter block. If
there is no local parameterization associated with this parameter
block, then <code class="docutils literal"><span class="pre">ParameterBlockLocalSize</span></code> = <code class="docutils literal"><span class="pre">ParameterBlockSize</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem17HasParameterBlockEPKd">
<span id="ceres::Problem::HasParameterBlock__doubleCPC"></span>bool <code class="descclassname">Problem::</code><code class="descname">HasParameterBlock</code><span class="sig-paren">(</span><em class="property">const</em> double *<em>values</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem17HasParameterBlockEPKd" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given parameter block present in the problem or not?</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem18GetParameterBlocksEP6vectorIPdE">
<span id="ceres::Problem::GetParameterBlocks__vector:doubleP:PC"></span>void <code class="descclassname">Problem::</code><code class="descname">GetParameterBlocks</code><span class="sig-paren">(</span>vector&lt;double *&gt; *<em>parameter_blocks</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem18GetParameterBlocksEP6vectorIPdE" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the passed <code class="docutils literal"><span class="pre">parameter_blocks</span></code> vector with pointers to the
parameter blocks currently in the problem. After this call,
<code class="docutils literal"><span class="pre">parameter_block.size()</span> <span class="pre">==</span> <span class="pre">NumParameterBlocks</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem17GetResidualBlocksEP6vectorI15ResidualBlockIdE">
<span id="ceres::Problem::GetResidualBlocks__vector:ResidualBlockId:PC"></span>void <code class="descclassname">Problem::</code><code class="descname">GetResidualBlocks</code><span class="sig-paren">(</span>vector&lt;ResidualBlockId&gt; *<em>residual_blocks</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem17GetResidualBlocksEP6vectorI15ResidualBlockIdE" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the passed <cite>residual_blocks</cite> vector with pointers to the
residual blocks currently in the problem. After this call,
<cite>residual_blocks.size() == NumResidualBlocks</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem34GetParameterBlocksForResidualBlockEK15ResidualBlockIdP6vectorIPdE">
<span id="ceres::Problem::GetParameterBlocksForResidualBlock__ResidualBlockIdC.vector:doubleP:PC"></span>void <code class="descclassname">Problem::</code><code class="descname">GetParameterBlocksForResidualBlock</code><span class="sig-paren">(</span><em class="property">const</em> ResidualBlockId <em>residual_block</em>, vector&lt;double *&gt; *<em>parameter_blocks</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem34GetParameterBlocksForResidualBlockEK15ResidualBlockIdP6vectorIPdE" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the parameter blocks that depend on the given residual
block.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres7Problem34GetResidualBlocksForParameterBlockEPKdP6vectorI15ResidualBlockIdE">
<span id="ceres::Problem::GetResidualBlocksForParameterBlock__doubleCP.vector:ResidualBlockId:PC"></span>void <code class="descclassname">Problem::</code><code class="descname">GetResidualBlocksForParameterBlock</code><span class="sig-paren">(</span><em class="property">const</em> double *<em>values</em>, vector&lt;ResidualBlockId&gt; *<em>residual_blocks</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres7Problem34GetResidualBlocksForParameterBlockEPKdP6vectorI15ResidualBlockIdE" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the residual blocks that depend on the given parameter
block.</p>
<p>If <cite>Problem::Options::enable_fast_removal</cite> is
<cite>true</cite>, then getting the residual blocks is fast and depends only
on the number of residual blocks. Otherwise, getting the residual
blocks for a parameter block will incur a scan of the entire
<a class="reference internal" href="#_CPPv2N5ceres7ProblemE" title="ceres::Problem"><code class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></code></a> object.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres31GetCostFunctionForResidualBlockEK15ResidualBlockId">
<span id="ceres::GetCostFunctionForResidualBlock__ResidualBlockIdCC"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction">CostFunction</a> *<code class="descclassname"></code><code class="descname">GetCostFunctionForResidualBlock</code><span class="sig-paren">(</span><em class="property">const</em> ResidualBlockId <em>residual_block</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres31GetCostFunctionForResidualBlockEK15ResidualBlockId" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the <a class="reference internal" href="#_CPPv2N5ceres12CostFunctionE" title="ceres::CostFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></code></a> for the given residual block.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK5ceres31GetLossFunctionForResidualBlockEK15ResidualBlockId">
<span id="ceres::GetLossFunctionForResidualBlock__ResidualBlockIdCC"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5ceres12LossFunctionE" title="ceres::LossFunction">LossFunction</a> *<code class="descclassname"></code><code class="descname">GetLossFunctionForResidualBlock</code><span class="sig-paren">(</span><em class="property">const</em> ResidualBlockId <em>residual_block</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK5ceres31GetLossFunctionForResidualBlockEK15ResidualBlockId" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the <a class="reference internal" href="#_CPPv2N5ceres12LossFunctionE" title="ceres::LossFunction"><code class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></code></a> for the given residual block.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N5ceres7Problem8EvaluateERKN7Problem15EvaluateOptionsEPdP6vectorIdEP6vectorIdEP9CRSMatrix">
<span id="ceres::Problem::Evaluate__Problem::EvaluateOptionsCR.doubleP.vector:double:P.vector:double:P.CRSMatrixP"></span>bool <code class="descclassname">Problem::</code><code class="descname">Evaluate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N5ceres7ProblemE" title="ceres::Problem">Problem</a>::<a class="reference internal" href="#_CPPv2N5ceres7Problem15EvaluateOptionsE" title="ceres::Problem::EvaluateOptions">EvaluateOptions</a> &amp;<em>options</em>, double *<em>cost</em>, vector&lt;double&gt; *<em>residuals</em>, vector&lt;double&gt; *<em>gradient</em>, <a class="reference internal" href="nnls_solving.html#_CPPv2N5ceres9CRSMatrixE" title="ceres::CRSMatrix">CRSMatrix</a> *<em>jacobian</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N5ceres7Problem8EvaluateERKN7Problem15EvaluateOptionsEPdP6vectorIdEP6vectorIdEP9CRSMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a <a class="reference internal" href="#_CPPv2N5ceres7ProblemE" title="ceres::Problem"><code class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></code></a>. Any of the output pointers can be
<cite>NULL</cite>. Which residual blocks and parameter blocks are used is
controlled by the <a class="reference internal" href="#_CPPv2N5ceres7Problem15EvaluateOptionsE" title="ceres::Problem::EvaluateOptions"><code class="xref cpp cpp-class docutils literal"><span class="pre">Problem::EvaluateOptions</span></code></a> struct below.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The evaluation will use the values stored in the memory
locations pointed to by the parameter block pointers used at the
time of the construction of the problem, for example in the
following code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">problem</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">MyCostFunction</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

<span class="kt">double</span> <span class="n">cost</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="n">problem</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">Problem</span><span class="o">::</span><span class="n">EvaluateOptions</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cost</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>The cost is evaluated at <cite>x = 1</cite>. If you wish to evaluate the
problem at <cite>x = 2</cite>, then</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">problem</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">Problem</span><span class="o">::</span><span class="n">EvaluateOptions</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cost</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">is the way to do so.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If no local parameterizations are used, then the size of
the gradient vector is the sum of the sizes of all the parameter
blocks. If a parameter block has a local parameterization, then
it contributes &#8220;LocalSize&#8221; entries to the gradient vector.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function cannot be called while the problem is being
solved, for example it cannot be called from an
<a class="reference internal" href="nnls_solving.html#_CPPv2N5ceres17IterationCallbackE" title="ceres::IterationCallback"><code class="xref cpp cpp-class docutils literal"><span class="pre">IterationCallback</span></code></a> at the end of an iteration during a
solve.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N5ceres7Problem15EvaluateOptionsE">
<span id="ceres::Problem::EvaluateOptions"></span><em class="property">class </em><code class="descclassname">Problem::</code><code class="descname">EvaluateOptions</code><a class="headerlink" href="#_CPPv2N5ceres7Problem15EvaluateOptionsE" title="Permalink to this definition">¶</a></dt>
<dd><p>Options struct that is used to control <a class="reference internal" href="#_CPPv2N5ceres7Problem8EvaluateERKN7Problem15EvaluateOptionsEPdP6vectorIdEP6vectorIdEP9CRSMatrix" title="ceres::Problem::Evaluate"><code class="xref cpp cpp-func docutils literal"><span class="pre">Problem::Evaluate()</span></code></a>.</p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N7Problem15EvaluateOptions16parameter_blocksE">
<span id="ceres::Problem::EvaluateOptions::parameter_blocks__vector:doubleP:"></span>vector&lt;double *&gt; <code class="descclassname">Problem::EvaluateOptions::</code><code class="descname">parameter_blocks</code><a class="headerlink" href="#_CPPv2N7Problem15EvaluateOptions16parameter_blocksE" title="Permalink to this definition">¶</a></dt>
<dd><p>The set of parameter blocks for which evaluation should be
performed. This vector determines the order in which parameter
blocks occur in the gradient vector and in the columns of the
jacobian matrix. If parameter_blocks is empty, then it is assumed
to be equal to a vector containing ALL the parameter
blocks. Generally speaking the ordering of the parameter blocks in
this case depends on the order in which they were added to the
problem and whether or not the user removed any parameter blocks.</p>
<p><strong>NOTE</strong> This vector should contain the same pointers as the ones
used to add parameter blocks to the Problem. These parameter block
should NOT point to new memory locations. Bad things will happen if
you do.</p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N7Problem15EvaluateOptions15residual_blocksE">
<span id="ceres::Problem::EvaluateOptions::residual_blocks__vector:ResidualBlockId:"></span>vector&lt;ResidualBlockId&gt; <code class="descclassname">Problem::EvaluateOptions::</code><code class="descname">residual_blocks</code><a class="headerlink" href="#_CPPv2N7Problem15EvaluateOptions15residual_blocksE" title="Permalink to this definition">¶</a></dt>
<dd><p>The set of residual blocks for which evaluation should be
performed. This vector determines the order in which the residuals
occur, and how the rows of the jacobian are ordered. If
residual_blocks is empty, then it is assumed to be equal to the
vector containing all the parameter blocks.</p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N7Problem15EvaluateOptions19apply_loss_functionE">
<span id="ceres::Problem::EvaluateOptions::apply_loss_function__b"></span>bool <code class="descclassname">Problem::EvaluateOptions::</code><code class="descname">apply_loss_function</code><a class="headerlink" href="#_CPPv2N7Problem15EvaluateOptions19apply_loss_functionE" title="Permalink to this definition">¶</a></dt>
<dd><p>Even though the residual blocks in the problem may contain loss
functions, setting apply_loss_function to false will turn off the
application of the loss function to the output of the cost
function. This is of use for example if the user wishes to analyse
the solution quality by studying the distribution of residuals
before and after the solve.</p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N7Problem15EvaluateOptions11num_threadsE">
<span id="ceres::Problem::EvaluateOptions::num_threads__i"></span>int <code class="descclassname">Problem::EvaluateOptions::</code><code class="descname">num_threads</code><a class="headerlink" href="#_CPPv2N7Problem15EvaluateOptions11num_threadsE" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of threads to use. (Requires OpenMP).</p>
</dd></dl>

</div>
<div class="section" id="rotation-h">
<h2><code class="docutils literal"><span class="pre">rotation.h</span></code><a class="headerlink" href="#rotation-h" title="Permalink to this headline">¶</a></h2>
<p>Many applications of Ceres Solver involve optimization problems where
some of the variables correspond to rotations. To ease the pain of
work with the various representations of rotations (angle-axis,
quaternion and matrix) we provide a handy set of templated
functions. These functions are templated so that the user can use them
within Ceres Solver&#8217;s automatic differentiation framework.</p>
<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres21AngleAxisToQuaternionEP1TP1T">
void <code class="descclassname"></code><code class="descname">AngleAxisToQuaternion</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2I0EN5ceres21AngleAxisToQuaternionEP1TP1T" title="ceres::AngleAxisToQuaternion::T">T</a> <em class="property">const</em> *<em>angle_axis</em>, <a class="reference internal" href="#_CPPv2I0EN5ceres21AngleAxisToQuaternionEP1TP1T" title="ceres::AngleAxisToQuaternion::T">T</a> *<em>quaternion</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres21AngleAxisToQuaternionEP1TP1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a value in combined axis-angle representation to a
quaternion.</p>
<p>The value <code class="docutils literal"><span class="pre">angle_axis</span></code> is a triple whose norm is an angle in radians,
and whose direction is aligned with the axis of rotation, and
<code class="docutils literal"><span class="pre">quaternion</span></code> is a 4-tuple that will contain the resulting quaternion.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres21QuaternionToAngleAxisEP1TP1T">
void <code class="descclassname"></code><code class="descname">QuaternionToAngleAxis</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2I0EN5ceres21QuaternionToAngleAxisEP1TP1T" title="ceres::QuaternionToAngleAxis::T">T</a> <em class="property">const</em> *<em>quaternion</em>, <a class="reference internal" href="#_CPPv2I0EN5ceres21QuaternionToAngleAxisEP1TP1T" title="ceres::QuaternionToAngleAxis::T">T</a> *<em>angle_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres21QuaternionToAngleAxisEP1TP1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a quaternion to the equivalent combined axis-angle
representation.</p>
<p>The value <code class="docutils literal"><span class="pre">quaternion</span></code> must be a unit quaternion - it is not
normalized first, and <code class="docutils literal"><span class="pre">angle_axis</span></code> will be filled with a value
whose norm is the angle of rotation in radians, and whose direction
is the axis of rotation.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>, int <code class="descclassname"></code><code class="descname">row_stride</code>, int <code class="descclassname"></code><code class="descname">col_stride</code>&gt;</dt>
<dt id="_CPPv2I0_i_iEN5ceres25RotationMatrixToAngleAxisERK13MatrixAdapterIK1T10row_stride10col_strideEP1T">
void <code class="descclassname"></code><code class="descname">RotationMatrixToAngleAxis</code><span class="sig-paren">(</span><em class="property">const</em> MatrixAdapter&lt;<em class="property">const</em> <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres25RotationMatrixToAngleAxisERK13MatrixAdapterIK1T10row_stride10col_strideEP1T" title="ceres::RotationMatrixToAngleAxis::T">T</a>, <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres25RotationMatrixToAngleAxisERK13MatrixAdapterIK1T10row_stride10col_strideEP1T" title="ceres::RotationMatrixToAngleAxis::row_stride">row_stride</a>, <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres25RotationMatrixToAngleAxisERK13MatrixAdapterIK1T10row_stride10col_strideEP1T" title="ceres::RotationMatrixToAngleAxis::col_stride">col_stride</a>&gt; &amp;<em>R</em>, <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres25RotationMatrixToAngleAxisERK13MatrixAdapterIK1T10row_stride10col_strideEP1T" title="ceres::RotationMatrixToAngleAxis::T">T</a> *<em>angle_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0_i_iEN5ceres25RotationMatrixToAngleAxisERK13MatrixAdapterIK1T10row_stride10col_strideEP1T" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>, int <code class="descclassname"></code><code class="descname">row_stride</code>, int <code class="descclassname"></code><code class="descname">col_stride</code>&gt;</dt>
<dt id="_CPPv2I0_i_iEN5ceres25AngleAxisToRotationMatrixEP1TRK13MatrixAdapterI1T10row_stride10col_strideE">
void <code class="descclassname"></code><code class="descname">AngleAxisToRotationMatrix</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2I0_i_iEN5ceres25AngleAxisToRotationMatrixEP1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::AngleAxisToRotationMatrix::T">T</a> <em class="property">const</em> *<em>angle_axis</em>, <em class="property">const</em> MatrixAdapter&lt;<a class="reference internal" href="#_CPPv2I0_i_iEN5ceres25AngleAxisToRotationMatrixEP1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::AngleAxisToRotationMatrix::T">T</a>, <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres25AngleAxisToRotationMatrixEP1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::AngleAxisToRotationMatrix::row_stride">row_stride</a>, <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres25AngleAxisToRotationMatrixEP1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::AngleAxisToRotationMatrix::col_stride">col_stride</a>&gt; &amp;<em>R</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0_i_iEN5ceres25AngleAxisToRotationMatrixEP1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres25RotationMatrixToAngleAxisEP1TP1T">
void <code class="descclassname"></code><code class="descname">RotationMatrixToAngleAxis</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2I0EN5ceres25RotationMatrixToAngleAxisEP1TP1T" title="ceres::RotationMatrixToAngleAxis::T">T</a> <em class="property">const</em> *<em>R</em>, <a class="reference internal" href="#_CPPv2I0EN5ceres25RotationMatrixToAngleAxisEP1TP1T" title="ceres::RotationMatrixToAngleAxis::T">T</a> *<em>angle_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres25RotationMatrixToAngleAxisEP1TP1T" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres25AngleAxisToRotationMatrixEP1TP1T">
void <code class="descclassname"></code><code class="descname">AngleAxisToRotationMatrix</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2I0EN5ceres25AngleAxisToRotationMatrixEP1TP1T" title="ceres::AngleAxisToRotationMatrix::T">T</a> <em class="property">const</em> *<em>angle_axis</em>, <a class="reference internal" href="#_CPPv2I0EN5ceres25AngleAxisToRotationMatrixEP1TP1T" title="ceres::AngleAxisToRotationMatrix::T">T</a> *<em>R</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres25AngleAxisToRotationMatrixEP1TP1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversions between 3x3 rotation matrix with given column and row strides and
axis-angle rotation representations. The functions that take a pointer to T instead
of a MatrixAdapter assume a column major representation with unit row stride and a column stride of 3.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>, int <code class="descclassname"></code><code class="descname">row_stride</code>, int <code class="descclassname"></code><code class="descname">col_stride</code>&gt;</dt>
<dt id="_CPPv2I0_i_iEN5ceres27EulerAnglesToRotationMatrixEPK1TRK13MatrixAdapterI1T10row_stride10col_strideE">
void <code class="descclassname"></code><code class="descname">EulerAnglesToRotationMatrix</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres27EulerAnglesToRotationMatrixEPK1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::EulerAnglesToRotationMatrix::T">T</a> *<em>euler</em>, <em class="property">const</em> MatrixAdapter&lt;<a class="reference internal" href="#_CPPv2I0_i_iEN5ceres27EulerAnglesToRotationMatrixEPK1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::EulerAnglesToRotationMatrix::T">T</a>, <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres27EulerAnglesToRotationMatrixEPK1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::EulerAnglesToRotationMatrix::row_stride">row_stride</a>, <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres27EulerAnglesToRotationMatrixEPK1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::EulerAnglesToRotationMatrix::col_stride">col_stride</a>&gt; &amp;<em>R</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0_i_iEN5ceres27EulerAnglesToRotationMatrixEPK1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres27EulerAnglesToRotationMatrixEPK1TiP1T">
void <code class="descclassname"></code><code class="descname">EulerAnglesToRotationMatrix</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres27EulerAnglesToRotationMatrixEPK1TiP1T" title="ceres::EulerAnglesToRotationMatrix::T">T</a> *<em>euler</em>, int <em>row_stride</em>, <a class="reference internal" href="#_CPPv2I0EN5ceres27EulerAnglesToRotationMatrixEPK1TiP1T" title="ceres::EulerAnglesToRotationMatrix::T">T</a> *<em>R</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres27EulerAnglesToRotationMatrixEPK1TiP1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversions between 3x3 rotation matrix with given column and row strides and
Euler angle (in degrees) rotation representations.</p>
<p>The {pitch,roll,yaw} Euler angles are rotations around the {x,y,z}
axes, respectively.  They are applied in that same order, so the
total rotation R is Rz * Ry * Rx.</p>
<p>The function that takes a pointer to T as the rotation matrix assumes a row
major representation with unit column stride and a row stride of 3.
The additional parameter row_stride is required to be 3.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>, int <code class="descclassname"></code><code class="descname">row_stride</code>, int <code class="descclassname"></code><code class="descname">col_stride</code>&gt;</dt>
<dt id="_CPPv2I0_i_iEN5ceres26QuaternionToScaledRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE">
void <code class="descclassname"></code><code class="descname">QuaternionToScaledRotation</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres26QuaternionToScaledRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::QuaternionToScaledRotation::T">T</a> <em>q</em>[4], <em class="property">const</em> MatrixAdapter&lt;<a class="reference internal" href="#_CPPv2I0_i_iEN5ceres26QuaternionToScaledRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::QuaternionToScaledRotation::T">T</a>, <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres26QuaternionToScaledRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::QuaternionToScaledRotation::row_stride">row_stride</a>, <a class="reference internal" href="#_CPPv2I0_i_iEN5ceres26QuaternionToScaledRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::QuaternionToScaledRotation::col_stride">col_stride</a>&gt; &amp;<em>R</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0_i_iEN5ceres26QuaternionToScaledRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres26QuaternionToScaledRotationEA4_K1TA3 * 3_1T">
void <code class="descclassname"></code><code class="descname">QuaternionToScaledRotation</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres26QuaternionToScaledRotationEA4_K1TA3 * 3_1T" title="ceres::QuaternionToScaledRotation::T">T</a> <em>q</em>[4], <a class="reference internal" href="#_CPPv2I0EN5ceres26QuaternionToScaledRotationEA4_K1TA3 * 3_1T" title="ceres::QuaternionToScaledRotation::T">T</a> <em>R</em>[3 * 3]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres26QuaternionToScaledRotationEA4_K1TA3 * 3_1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a 4-vector to a 3x3 scaled rotation matrix.</p>
<p>The choice of rotation is such that the quaternion
<span class="math">\(\begin{bmatrix} 1 &amp;0 &amp;0 &amp;0\end{bmatrix}\)</span> goes to an identity
matrix and for small <span class="math">\(a, b, c\)</span> the quaternion
<span class="math">\(\begin{bmatrix}1 &amp;a &amp;b &amp;c\end{bmatrix}\)</span> goes to the matrix</p>
<div class="math">
\[\begin{split}I + 2 \begin{bmatrix} 0 &amp; -c &amp; b \\ c &amp; 0 &amp; -a\\ -b &amp; a &amp; 0
      \end{bmatrix} + O(q^2)\end{split}\]</div>
<p>which corresponds to a Rodrigues approximation, the last matrix
being the cross-product matrix of <span class="math">\(\begin{bmatrix} a&amp; b&amp;
c\end{bmatrix}\)</span>. Together with the property that <span class="math">\(R(q1 * q2)
= R(q1) * R(q2)\)</span> this uniquely defines the mapping from <span class="math">\(q\)</span> to
<span class="math">\(R\)</span>.</p>
<p>In the function that accepts a pointer to T instead of a MatrixAdapter,
the rotation matrix <code class="docutils literal"><span class="pre">R</span></code> is a row-major matrix with unit column stride
and a row stride of 3.</p>
<p>No normalization of the quaternion is performed, i.e.
<span class="math">\(R = \|q\|^2  Q\)</span>, where <span class="math">\(Q\)</span> is an orthonormal matrix
such that <span class="math">\(\det(Q) = 1\)</span> and <span class="math">\(Q*Q' = I\)</span>.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres20QuaternionToRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE">
void <code class="descclassname"></code><code class="descname">QuaternionToRotation</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres20QuaternionToRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::QuaternionToRotation::T">T</a> <em>q</em>[4], <em class="property">const</em> MatrixAdapter&lt;<a class="reference internal" href="#_CPPv2I0EN5ceres20QuaternionToRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::QuaternionToRotation::T">T</a>, row_stride, col_stride&gt; &amp;<em>R</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres20QuaternionToRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres20QuaternionToRotationEA4_K1TA3 * 3_1T">
void <code class="descclassname"></code><code class="descname">QuaternionToRotation</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres20QuaternionToRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::QuaternionToRotation::T">T</a> <em>q</em>[4], <a class="reference internal" href="#_CPPv2I0EN5ceres20QuaternionToRotationEA4_K1TRK13MatrixAdapterI1T10row_stride10col_strideE" title="ceres::QuaternionToRotation::T">T</a> <em>R</em>[3 * 3]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres20QuaternionToRotationEA4_K1TA3 * 3_1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above except that the rotation matrix is normalized by the
Frobenius norm, so that <span class="math">\(R R' = I\)</span> (and <span class="math">\(\det(R) = 1\)</span>).</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres25UnitQuaternionRotatePointEA4_K1TA3_K1TA3_1T">
void <code class="descclassname"></code><code class="descname">UnitQuaternionRotatePoint</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres25UnitQuaternionRotatePointEA4_K1TA3_K1TA3_1T" title="ceres::UnitQuaternionRotatePoint::T">T</a> <em>q</em>[4], <em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres25UnitQuaternionRotatePointEA4_K1TA3_K1TA3_1T" title="ceres::UnitQuaternionRotatePoint::T">T</a> <em>pt</em>[3], <a class="reference internal" href="#_CPPv2I0EN5ceres25UnitQuaternionRotatePointEA4_K1TA3_K1TA3_1T" title="ceres::UnitQuaternionRotatePoint::T">T</a> <em>result</em>[3]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres25UnitQuaternionRotatePointEA4_K1TA3_K1TA3_1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates a point pt by a quaternion q:</p>
<div class="math">
\[\text{result} = R(q)  \text{pt}\]</div>
<p>Assumes the quaternion is unit norm. If you pass in a quaternion
with <span class="math">\(|q|^2 = 2\)</span> then you WILL NOT get back 2 times the
result you get for a unit quaternion.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres21QuaternionRotatePointEA4_K1TA3_K1TA3_1T">
void <code class="descclassname"></code><code class="descname">QuaternionRotatePoint</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres21QuaternionRotatePointEA4_K1TA3_K1TA3_1T" title="ceres::QuaternionRotatePoint::T">T</a> <em>q</em>[4], <em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres21QuaternionRotatePointEA4_K1TA3_K1TA3_1T" title="ceres::QuaternionRotatePoint::T">T</a> <em>pt</em>[3], <a class="reference internal" href="#_CPPv2I0EN5ceres21QuaternionRotatePointEA4_K1TA3_K1TA3_1T" title="ceres::QuaternionRotatePoint::T">T</a> <em>result</em>[3]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres21QuaternionRotatePointEA4_K1TA3_K1TA3_1T" title="Permalink to this definition">¶</a></dt>
<dd><p>With this function you do not need to assume that <span class="math">\(q\)</span> has unit norm.
It does assume that the norm is non-zero.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres17QuaternionProductEA4_K1TA4_K1TA4_1T">
void <code class="descclassname"></code><code class="descname">QuaternionProduct</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres17QuaternionProductEA4_K1TA4_K1TA4_1T" title="ceres::QuaternionProduct::T">T</a> <em>z</em>[4], <em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres17QuaternionProductEA4_K1TA4_K1TA4_1T" title="ceres::QuaternionProduct::T">T</a> <em>w</em>[4], <a class="reference internal" href="#_CPPv2I0EN5ceres17QuaternionProductEA4_K1TA4_K1TA4_1T" title="ceres::QuaternionProduct::T">T</a> <em>zw</em>[4]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres17QuaternionProductEA4_K1TA4_K1TA4_1T" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[zw = z * w\]</div>
<p>where <span class="math">\(*\)</span> is the Quaternion product between 4-vectors.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres12CrossProductEA3_K1TA3_K1TA3_1T">
void <code class="descclassname"></code><code class="descname">CrossProduct</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres12CrossProductEA3_K1TA3_K1TA3_1T" title="ceres::CrossProduct::T">T</a> <em>x</em>[3], <em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres12CrossProductEA3_K1TA3_K1TA3_1T" title="ceres::CrossProduct::T">T</a> <em>y</em>[3], <a class="reference internal" href="#_CPPv2I0EN5ceres12CrossProductEA3_K1TA3_K1TA3_1T" title="ceres::CrossProduct::T">T</a> <em>x_cross_y</em>[3]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres12CrossProductEA3_K1TA3_K1TA3_1T" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\text{x_cross_y} = x \times y\]</div>
</dd></dl>

<dl class="function">
<dt>
template&lt;typename <code class="descname">T</code>&gt;</dt>
<dt id="_CPPv2I0EN5ceres20AngleAxisRotatePointEA3_K1TA3_K1TA3_1T">
void <code class="descclassname"></code><code class="descname">AngleAxisRotatePoint</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres20AngleAxisRotatePointEA3_K1TA3_K1TA3_1T" title="ceres::AngleAxisRotatePoint::T">T</a> <em>angle_axis</em>[3], <em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN5ceres20AngleAxisRotatePointEA3_K1TA3_K1TA3_1T" title="ceres::AngleAxisRotatePoint::T">T</a> <em>pt</em>[3], <a class="reference internal" href="#_CPPv2I0EN5ceres20AngleAxisRotatePointEA3_K1TA3_K1TA3_1T" title="ceres::AngleAxisRotatePoint::T">T</a> <em>result</em>[3]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN5ceres20AngleAxisRotatePointEA3_K1TA3_K1TA3_1T" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[y = R(\text{angle_axis}) x\]</div>
</dd></dl>

</div>
<div class="section" id="cubic-interpolation">
<h2>Cubic Interpolation<a class="headerlink" href="#cubic-interpolation" title="Permalink to this headline">¶</a></h2>
<p>Optimization problems often involve functions that are given in the
form of a table of values, for example an image. Evaluating these
functions and their derivatives requires interpolating these
values. Interpolating tabulated functions is a vast area of research
and there are a lot of libraries which implement a variety of
interpolation schemes. However, using them within the automatic
differentiation framework in Ceres is quite painful. To this end,
Ceres provides the ability to interpolate one dimensional and two
dimensional tabular functions.</p>
<p>The one dimensional interpolation is based on the Cubic Hermite
Spline, also known as the Catmull-Rom Spline. This produces a first
order differentiable interpolating function. The two dimensional
interpolation scheme is a generalization of the one dimensional scheme
where the interpolating function is assumed to be separable in the two
dimensions,</p>
<p>More details of the construction can be found <a class="reference external" href="http://www.ipol.im/pub/art/2011/g_lmii/">Linear Methods for
Image Interpolation</a> by
Pascal Getreuer.</p>
<dl class="class">
<dt id="_CPPv2N5ceres17CubicInterpolatorE">
<span id="ceres::CubicInterpolator"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">CubicInterpolator</code><a class="headerlink" href="#_CPPv2N5ceres17CubicInterpolatorE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Given as input an infinite one dimensional grid, which provides the
following interface.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Grid1D</span> <span class="p">{</span>
  <span class="n">enum</span> <span class="p">{</span> <span class="n">DATA_DIMENSION</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">};</span>
  <span class="n">void</span> <span class="n">GetValue</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Where, <code class="docutils literal"><span class="pre">GetValue</span></code> gives us the value of a function <span class="math">\(f\)</span>
(possibly vector valued) for any integer <span class="math">\(n\)</span> and the enum
<code class="docutils literal"><span class="pre">DATA_DIMENSION</span></code> indicates the dimensionality of the function being
interpolated. For example if you are interpolating rotations in
axis-angle format over time, then <code class="docutils literal"><span class="pre">DATA_DIMENSION</span> <span class="pre">=</span> <span class="pre">3</span></code>.</p>
<p><a class="reference internal" href="#_CPPv2N5ceres17CubicInterpolatorE" title="ceres::CubicInterpolator"><code class="xref cpp cpp-class docutils literal"><span class="pre">CubicInterpolator</span></code></a> uses Cubic Hermite splines to produce a
smooth approximation to it that can be used to evaluate the
<span class="math">\(f(x)\)</span> and <span class="math">\(f'(x)\)</span> at any point on the real number
line. For example, the following code interpolates an array of four
numbers.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">double</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">};</span>
<span class="n">Grid1D</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">CubicInterpolator</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
<span class="n">double</span> <span class="n">f</span><span class="p">,</span> <span class="n">dfdx</span><span class="p">;</span>
<span class="n">interpolator</span><span class="o">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dfdx</span><span class="p">);</span>
</pre></div>
</div>
<p>In the above code we use <code class="docutils literal"><span class="pre">Grid1D</span></code> a templated helper class that
allows easy interfacing between <code class="docutils literal"><span class="pre">C++</span></code> arrays and
<a class="reference internal" href="#_CPPv2N5ceres17CubicInterpolatorE" title="ceres::CubicInterpolator"><code class="xref cpp cpp-class docutils literal"><span class="pre">CubicInterpolator</span></code></a>.</p>
<p><code class="docutils literal"><span class="pre">Grid1D</span></code> supports vector valued functions where the various
coordinates of the function can be interleaved or stacked. It also
allows the use of any numeric type as input, as long as it can be
safely cast to a double.</p>
<dl class="class">
<dt id="_CPPv2N5ceres19BiCubicInterpolatorE">
<span id="ceres::BiCubicInterpolator"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">BiCubicInterpolator</code><a class="headerlink" href="#_CPPv2N5ceres19BiCubicInterpolatorE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Given as input an infinite two dimensional grid, which provides the
following interface:</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Grid2D</span> <span class="p">{</span>
  <span class="n">enum</span> <span class="p">{</span> <span class="n">DATA_DIMENSION</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>
  <span class="n">void</span> <span class="n">GetValue</span><span class="p">(</span><span class="nb">int</span> <span class="n">row</span><span class="p">,</span> <span class="nb">int</span> <span class="n">col</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Where, <code class="docutils literal"><span class="pre">GetValue</span></code> gives us the value of a function <span class="math">\(f\)</span>
(possibly vector valued) for any pair of integers <code class="code docutils literal"><span class="pre">row</span></code> and
<code class="code docutils literal"><span class="pre">col</span></code> and the enum <code class="docutils literal"><span class="pre">DATA_DIMENSION</span></code> indicates the
dimensionality of the function being interpolated. For example if you
are interpolating a color image with three channels (Red, Green &amp;
Blue), then <code class="docutils literal"><span class="pre">DATA_DIMENSION</span> <span class="pre">=</span> <span class="pre">3</span></code>.</p>
<p><a class="reference internal" href="#_CPPv2N5ceres19BiCubicInterpolatorE" title="ceres::BiCubicInterpolator"><code class="xref cpp cpp-class docutils literal"><span class="pre">BiCubicInterpolator</span></code></a> uses the cubic convolution interpolation
algorithm of R. Keys <a class="reference internal" href="bibliography.html#keys" id="id4">[Keys]</a>, to produce a smooth approximation to it
that can be used to evaluate the <span class="math">\(f(r,c)\)</span>, <span class="math">\(\frac{\partial
f(r,c)}{\partial r}\)</span> and <span class="math">\(\frac{\partial f(r,c)}{\partial c}\)</span> at
any any point in the real plane.</p>
<p>For example the following code interpolates a two dimensional array.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">double</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span>
                       <span class="mf">3.6</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span>  <span class="mf">4.2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span>
                       <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">3.1</span><span class="p">,</span> <span class="mf">5.2</span><span class="p">};</span>
<span class="n">Grid2D</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span>  <span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">BiCubicInterpolator</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
<span class="n">double</span> <span class="n">f</span><span class="p">,</span> <span class="n">dfdr</span><span class="p">,</span> <span class="n">dfdc</span><span class="p">;</span>
<span class="n">interpolator</span><span class="o">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dfdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dfdc</span><span class="p">);</span>
</pre></div>
</div>
<p>In the above code, the templated helper class <code class="docutils literal"><span class="pre">Grid2D</span></code> is used to
make a <code class="docutils literal"><span class="pre">C++</span></code> array look like a two dimensional table to
<a class="reference internal" href="#_CPPv2N5ceres19BiCubicInterpolatorE" title="ceres::BiCubicInterpolator"><code class="xref cpp cpp-class docutils literal"><span class="pre">BiCubicInterpolator</span></code></a>.</p>
<p><code class="docutils literal"><span class="pre">Grid2D</span></code> supports row or column major layouts. It also supports
vector valued functions where the individual coordinates of the
function may be interleaved or stacked. It also allows the use of any
numeric type as input, as long as it can be safely cast to double.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="nnls_solving.html" class="btn btn-neutral float-right" title="Solving Non-linear Least Squares" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="interfacing_with_autodiff.html" class="btn btn-neutral" title="Interfacing with Automatic Differentiation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016 Google Inc.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.13.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
      MathJax.Hub.Config({
          "HTML-CSS": {
            availableFonts: ["TeX"]
          }
        });
      </script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49769510-1', 'ceres-solver.org');
  ga('send', 'pageview');
</script>


</body>
</html>